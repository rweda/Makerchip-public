// Generated by SandPiper(TM).
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


// For X injection on assignments, disableable using `define SP_PHYS.
`ifdef WHEN
   $warning("WHEN macro redefined.");
`endif
`ifdef SP_PHYS
   `define WHEN(valid_sig)
`else
   `define WHEN(valid_sig) !valid_sig ? 'x :
`endif


genvar hier;


//
// Signals declared top-level.
//

// For |pipe$State.
logic [7:0] w_PIPE_State_a1;
logic [7:0] PIPE_State_a2;
logic [7:0] PIPE_State_a3;
logic [7:0] PIPE_State_a4;

// For |pipe$bar.
logic [7:0] w_PIPE_bar_a4 /* without X injection for "when" condition */;
logic [7:0] PIPE_bar_a4;

// For |pipe$cnt.
logic [7:0] w_PIPE_cnt_a0;
logic [7:0] PIPE_cnt_a1;
logic [7:0] PIPE_cnt_a2;
logic [7:0] PIPE_cnt_a3;
logic [7:0] PIPE_cnt_a4;

// For |pipe$reset.
logic PIPE_reset_a0;
logic PIPE_reset_a1;
logic PIPE_reset_a2;
logic PIPE_reset_a3;
logic PIPE_reset_a4;

// For |pipe$valid.
logic PIPE_valid_a0;
logic PIPE_valid_a1;
logic PIPE_valid_a2;
logic PIPE_valid_a3;
logic PIPE_valid_a4;

// For |pipe$valid2.
logic PIPE_valid2_a0;
logic PIPE_valid2_a1;
logic PIPE_valid2_a2;
logic PIPE_valid2_a3;
logic PIPE_valid2_a4;

// For |pipe/hier$failed.
logic [1:0] PIPE_Hier_failed_a4;

// For |pipe/hier$g0_valid2.
logic PIPE_Hier_g0_valid2_a4 [1:0];

// For |pipe2$State.
logic w_PIPE2_State_n1 /* without recirculation for "when" condition */;
logic PIPE2_State_n1;
logic PIPE2_State_a0;

// For |pipe2$bob.
logic PIPE2_bob_a0;

// For |pipe2$odd.
logic PIPE2_odd_a0;
logic PIPE2_odd_a1;
logic PIPE2_odd_a2;
logic PIPE2_odd_a3;

// For |pipe2/copy$Five.
logic [7:0] w_PIPE2_Copy_Five_a2;
logic [7:0] PIPE2_Copy_Five_a3;

// For |pipe2/copy$Four.
logic [7:0] w_PIPE2_Copy_Four_a2;
logic [7:0] PIPE2_Copy_Four_a3;

// For |pipe2/copy$One.
logic [7:0] w_PIPE2_Copy_One_a2;
logic [7:0] PIPE2_Copy_One_a3;

// For |pipe2/copy$Seven.
logic [7:0] w_PIPE2_Copy_Seven_a2;
logic [7:0] PIPE2_Copy_Seven_a3;

// For |pipe2/copy$Six.
logic [7:0] w_PIPE2_Copy_Six_a2;
logic [7:0] PIPE2_Copy_Six_a3;

// For |pipe2/copy$Three.
logic [7:0] w_PIPE2_Copy_Three_a2;
logic [7:0] PIPE2_Copy_Three_a3;

// For |pipe2/copy$Two.
logic [7:0] w_PIPE2_Copy_Two_a2;
logic [7:0] PIPE2_Copy_Two_a3;

// For |pipe2/copy$bob.
logic w_PIPE2_Copy_bob_a0 /* without X injection for "when" condition */;
logic PIPE2_Copy_bob_a0;

// For |pipe2/copy$eight.
logic [7:0] w_PIPE2_Copy_eight_a3 /* without X injection for "when" condition */;
logic [7:0] PIPE2_Copy_eight_a3;


//
// Scope: |pipe
//

// Clock signals.
logic clkF_PIPE_valid_a3 ;
logic clkF_PIPE_valid_a4 ;
logic clkF_PIPE_valid_a5 ;
logic clkP_PIPE_valid_a1 ;
logic clkP_PIPE_valid_a2 ;
logic clkP_PIPE_valid_a3 ;
logic clkP_PIPE_valid_a4 ;

//
// Scope: |pipe/hier[1:0]
//

// Clock signals.
logic clkF_PIPE_Hier_g0_valid2_a5 [1:0];

//
// Scope: |pipe2
//

// Clock signals.
logic clkF_PIPE2_odd_a1 ;
logic clkF_PIPE2_odd_a4 ;



   //
   // Scope: |pipe
   //

      // Staging of $State.
      always_ff @(posedge clkF_PIPE_valid_a3) PIPE_State_a2[7:0] <= w_PIPE_State_a1[7:0];
      always_ff @(posedge clkF_PIPE_valid_a4) PIPE_State_a3[7:0] <= PIPE_State_a2[7:0];
      always_ff @(posedge clkF_PIPE_valid_a5) PIPE_State_a4[7:0] <= PIPE_State_a3[7:0];

      // Inject X when invalid.
      assign PIPE_bar_a4 = `WHEN(PIPE_valid_a4) w_PIPE_bar_a4;
      // Staging of $cnt.
      always_ff @(posedge clkP_PIPE_valid_a1) PIPE_cnt_a1[7:0] <= w_PIPE_cnt_a0[7:0];
      always_ff @(posedge clkP_PIPE_valid_a2) PIPE_cnt_a2[7:0] <= PIPE_cnt_a1[7:0];
      always_ff @(posedge clkP_PIPE_valid_a3) PIPE_cnt_a3[7:0] <= PIPE_cnt_a2[7:0];
      always_ff @(posedge clkP_PIPE_valid_a4) PIPE_cnt_a4[7:0] <= PIPE_cnt_a3[7:0];

      // Staging of $reset.
      always_ff @(posedge clk) PIPE_reset_a1 <= PIPE_reset_a0;
      always_ff @(posedge clk) PIPE_reset_a2 <= PIPE_reset_a1;
      always_ff @(posedge clk) PIPE_reset_a3 <= PIPE_reset_a2;
      always_ff @(posedge clk) PIPE_reset_a4 <= PIPE_reset_a3;

      // Staging of $valid.
      always_ff @(posedge clk) PIPE_valid_a1 <= PIPE_valid_a0;
      always_ff @(posedge clk) PIPE_valid_a2 <= PIPE_valid_a1;
      always_ff @(posedge clk) PIPE_valid_a3 <= PIPE_valid_a2;
      always_ff @(posedge clk) PIPE_valid_a4 <= PIPE_valid_a3;

      // Staging of $valid2.
      always_ff @(posedge clk) PIPE_valid2_a1 <= PIPE_valid2_a0;
      always_ff @(posedge clk) PIPE_valid2_a2 <= PIPE_valid2_a1;
      always_ff @(posedge clk) PIPE_valid2_a3 <= PIPE_valid2_a2;
      always_ff @(posedge clk) PIPE_valid2_a4 <= PIPE_valid2_a3;


      //
      // Scope: /hier[1:0]
      //
      for (hier = 0; hier <= 1; hier++) begin : L1gen_PIPE_Hier
         // Update state with next state or hold.
         assign L1_PIPE_Hier[hier].L1_Cnt_a3 = !PIPE_Hier_g0_valid2_a4[hier] ? L1_PIPE_Hier[hier].L1_Cnt_a4[7:0] : L1_PIPE_Hier[hier].w_L1_Cnt_a3;
         // Staging of $Cnt.
         always_ff @(posedge clkF_PIPE_Hier_g0_valid2_a5[hier]) L1_PIPE_Hier[hier].L1_Cnt_a4[7:0] <= L1_PIPE_Hier[hier].L1_Cnt_a3[7:0];

         // Update state with next state or hold.
         assign L1_PIPE_Hier[hier].L1_Foo_a3 = !PIPE_Hier_g0_valid2_a4[hier] ? L1_PIPE_Hier[hier].L1_Foo_a4[7:0] : L1_PIPE_Hier[hier].w_L1_Foo_a3;
         // Staging of $Foo.
         always_ff @(posedge clkF_PIPE_Hier_g0_valid2_a5[hier]) L1_PIPE_Hier[hier].L1_Foo_a4[7:0] <= L1_PIPE_Hier[hier].L1_Foo_a3[7:0];

         // Inject X when invalid.
         assign L1_PIPE_Hier[hier].L1_foo_a4 = `WHEN(PIPE_Hier_g0_valid2_a4[hier]) L1_PIPE_Hier[hier].w_L1_foo_a4;
         // Staging of an unconditioned version of a condition signal.
         assign PIPE_Hier_g0_valid2_a4[hier] = L1_PIPE_Hier[hier].L1_valid2_a4 && PIPE_valid_a4;

         // Inject X when invalid.
         assign L1_PIPE_Hier[hier].L1_valid2_a4 = `WHEN(PIPE_valid_a4) L1_PIPE_Hier[hier].w_L1_valid2_a4;
      end


   //
   // Scope: |pipe2
   //

      // Update state with next state or hold.
      assign PIPE2_State_n1 = !PIPE2_odd_a0 ? PIPE2_State_a0 : w_PIPE2_State_n1;
      // Staging of $State.
      always_ff @(posedge clkF_PIPE2_odd_a1) PIPE2_State_a0 <= PIPE2_State_n1;

      // Staging of $odd.
      always_ff @(posedge clk) PIPE2_odd_a1 <= PIPE2_odd_a0;
      always_ff @(posedge clk) PIPE2_odd_a2 <= PIPE2_odd_a1;
      always_ff @(posedge clk) PIPE2_odd_a3 <= PIPE2_odd_a2;


      //
      // Scope: /copy
      //

         // Staging of $Five.
         always_ff @(posedge clkF_PIPE2_odd_a4) PIPE2_Copy_Five_a3[7:0] <= w_PIPE2_Copy_Five_a2[7:0];

         // Staging of $Four.
         always_ff @(posedge clkF_PIPE2_odd_a4) PIPE2_Copy_Four_a3[7:0] <= w_PIPE2_Copy_Four_a2[7:0];

         // Staging of $One.
         always_ff @(posedge clkF_PIPE2_odd_a4) PIPE2_Copy_One_a3[7:0] <= w_PIPE2_Copy_One_a2[7:0];

         // Staging of $Seven.
         always_ff @(posedge clkF_PIPE2_odd_a4) PIPE2_Copy_Seven_a3[7:0] <= w_PIPE2_Copy_Seven_a2[7:0];

         // Staging of $Six.
         always_ff @(posedge clkF_PIPE2_odd_a4) PIPE2_Copy_Six_a3[7:0] <= w_PIPE2_Copy_Six_a2[7:0];

         // Staging of $Three.
         always_ff @(posedge clkF_PIPE2_odd_a4) PIPE2_Copy_Three_a3[7:0] <= w_PIPE2_Copy_Three_a2[7:0];

         // Staging of $Two.
         always_ff @(posedge clkF_PIPE2_odd_a4) PIPE2_Copy_Two_a3[7:0] <= w_PIPE2_Copy_Two_a2[7:0];

         // Inject X when invalid.
         assign PIPE2_Copy_bob_a0 = `WHEN(PIPE2_odd_a0) w_PIPE2_Copy_bob_a0;
         // Inject X when invalid.
         assign PIPE2_Copy_eight_a3 = `WHEN(PIPE2_odd_a3) w_PIPE2_Copy_eight_a3;





//
// Gated clocks.
//



   //
   // Scope: |pipe
   //

      clk_gate gen_clkF_PIPE_valid_a3(clkF_PIPE_valid_a3, clk, PIPE_valid_a2, 1'b1, 1'b0);
      clk_gate gen_clkF_PIPE_valid_a4(clkF_PIPE_valid_a4, clk, PIPE_valid_a3, 1'b1, 1'b0);
      clk_gate gen_clkF_PIPE_valid_a5(clkF_PIPE_valid_a5, clk, PIPE_valid_a4, 1'b1, 1'b0);
      clk_gate gen_clkP_PIPE_valid_a1(clkP_PIPE_valid_a1, clk, 1'b1, (PIPE_valid_a0 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_PIPE_valid_a2(clkP_PIPE_valid_a2, clk, 1'b1, (PIPE_valid_a1 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_PIPE_valid_a3(clkP_PIPE_valid_a3, clk, 1'b1, (PIPE_valid_a2 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_PIPE_valid_a4(clkP_PIPE_valid_a4, clk, 1'b1, (PIPE_valid_a3 ? 1'b1 : 1'bx), 1'b0);

      //
      // Scope: /hier[1:0]
      //
      for (hier = 0; hier <= 1; hier++) begin : L1clk_PIPE_Hier
         clk_gate gen_clkF_PIPE_Hier_g0_valid2_a5(clkF_PIPE_Hier_g0_valid2_a5[hier], clk, PIPE_Hier_g0_valid2_a4[hier], 1'b1, 1'b0);
      end


   //
   // Scope: |pipe2
   //

      clk_gate gen_clkF_PIPE2_odd_a1(clkF_PIPE2_odd_a1, clk, PIPE2_odd_a0, 1'b1, 1'b0);
      clk_gate gen_clkF_PIPE2_odd_a4(clkF_PIPE2_odd_a4, clk, PIPE2_odd_a3, 1'b1, 1'b0);



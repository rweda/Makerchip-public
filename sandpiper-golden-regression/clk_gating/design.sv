//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM)

module clk_gating(input logic clk, input logic reset, input logic [15:0] cyc_cnt, output logic passed, output logic failed); 
   logic [7:0] nine;
`include "design_gen.sv"
   // Pipesignal and state assignment under when earlier condition.
   //_|pipe
      //_@0
         assign PIPE_reset_a0 = reset;
         assign PIPE_valid_a0 = PIPE_reset_a0 ? 1'b1 : ! PIPE_valid_a1;  // Assert every other cycle.
         assign PIPE_valid2_a0 = PIPE_reset_a0 ? 1'b1 : PIPE_reset_a1 ? 1'b0 : PIPE_valid2_a3;  // Deassert every 3rd cycle.
   //_|pipe
      //_?$valid
         //_@0
            assign w_PIPE_cnt_a0[7:0] = cyc_cnt[7:0];
         //_@2
            assign w_PIPE_State_a1[7:0] = PIPE_cnt_a2;
         //_@4
            assign w_PIPE_bar_a4[7:0] = PIPE_cnt_a4;
            // Pipesignal and state assignment under same-stage nested when condition.
            for (hier = 0; hier <= 1; hier++) begin : L1_PIPE_Hier logic [7:0] w_L1_Cnt_a3; logic [7:0] L1_Cnt_a3; logic [7:0] L1_Cnt_a4; logic [7:0] w_L1_Foo_a3; logic [7:0] L1_Foo_a3; logic [7:0] L1_Foo_a4; logic [7:0] w_L1_foo_a4; logic [7:0] L1_foo_a4; logic w_L1_valid2_a4; logic L1_valid2_a4; //_/hier
               assign w_L1_valid2_a4 = PIPE_valid2_a4;
               //_?$valid2
                  assign w_L1_foo_a4[7:0] = PIPE_bar_a4;
                  assign w_L1_Foo_a3[7:0] = PIPE_bar_a4;
                  assign w_L1_Cnt_a3[7:0] = PIPE_reset_a4 ? 8'b0 : L1_Cnt_a4 + 1'b1;
                  /*SV_plus*/
                     always_ff @(posedge clk) begin
                        if (PIPE_valid_a4 && L1_valid2_a4 && ! PIPE_reset_a4 && ! PIPE_reset_a0) begin
                           $display("hier[%h], cyc: %h, Cnt: %h", hier, cyc_cnt, L1_Cnt_a3);
                        end
                     end end
            `BOGUS_USE(PIPE_State_a4)
      
   //_|pipe2
      //_@0
         assign PIPE2_odd_a0 = reset ? 0 : ! PIPE2_odd_a1;
         assign PIPE2_bob_a0 = PIPE2_odd_a1;
      //_?$odd
         //_@0
            assign w_PIPE2_State_n1 = reset ? 0 : PIPE2_odd_a0;
            `BOGUS_USE(PIPE2_State_n1)
         // Conditioned $ANY.
         //_/copy
            //_@0
               assign {w_PIPE2_Copy_bob_a0} = {PIPE2_bob_a0};
            //_@0
               `BOGUS_USE(PIPE2_Copy_bob_a0)
            // Block and multiple state assignments.
            //_@3
               always_comb begin
                  w_PIPE2_Copy_One_a2[7:0] = 8'd1;
                  w_PIPE2_Copy_Two_a2[7:0] = 8'd2; end
               /*SV_plus*/
                  assign w_PIPE2_Copy_Three_a2[7:0] = 8'd3;
                  assign w_PIPE2_Copy_Four_a2[7:0] = 8'd4;
               assign {w_PIPE2_Copy_Five_a2[7:0], w_PIPE2_Copy_Six_a2[7:0]} = {8'd5, 8'd6};
               assign {w_PIPE2_Copy_Seven_a2[7:0], w_PIPE2_Copy_eight_a3[7:0], nine} = {8'd7, 8'd8, 8'd9};
               `BOGUS_USE(PIPE2_Copy_One_a3 PIPE2_Copy_Two_a3 PIPE2_Copy_Three_a3 PIPE2_Copy_Four_a3 PIPE2_Copy_Five_a3 PIPE2_Copy_Six_a3 PIPE2_Copy_Seven_a3 PIPE2_Copy_eight_a3)
               
               
                  
   // Detect failure.
   //_|pipe
      //_@4
         for (hier = 0; hier <= 1; hier++) begin : L1b_PIPE_Hier logic L1_bad_a4; logic L1_final_cnt_a4; //_/hier
            assign L1_bad_a4 = (L1_PIPE_Hier[hier].L1_foo_a4 != L1_PIPE_Hier[hier].L1_Foo_a3) && (PIPE_valid_a4 && PIPE_valid2_a4);
            assign L1_final_cnt_a4 = L1_PIPE_Hier[hier].L1_Cnt_a4 == 8'd12;
            assign PIPE_Hier_failed_a4[hier] = ! reset && ! PIPE_reset_a4 && (L1_bad_a4 || (cyc_cnt == 39 && ! L1_final_cnt_a4)); end
      
         // Fail if either /hier[*] failed.
         assign passed = cyc_cnt > 40;
         assign failed = | PIPE_Hier_failed_a4;
         

//_\SV
endmodule


// Undefine macros defined by SandPiper (in "design_gen.sv").
`undef BOGUS_USE
`undef WHEN

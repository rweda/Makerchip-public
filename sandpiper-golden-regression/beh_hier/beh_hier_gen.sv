// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// (Installed here: /home/steve/repos/mono/sandpiper/distro.)
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


genvar core, inst;


//
// Signals declared top-level.
//

// For >core>inst|pipe1$imm_data.
logic Core_Inst_PIPE1_imm_data_a3 [1:0][3:0];

// For >core>inst|pipe1$op_a_src.
logic Core_Inst_PIPE1_op_a_src_a3 [1:0][3:0];

// For >core>inst|pipe1$op_b.
logic Core_Inst_PIPE1_op_b_a4 [1:0][3:0];

// For >core>inst|pipe1$opcode.
logic Core_Inst_PIPE1_opcode_a4 [1:0][3:0];

// For >it$bar.
logic It_bar_a0;

// For >it$foo.
logic It_foo_a0;

// For |conditions$valid1.
logic CONDITIONS_valid1_a1;

// For |conditions>tmp2$conditioned.
logic w_CONDITIONS_Tmp2_conditioned_a3;

// For |conditions>tmp2$g0_valid2.
logic CONDITIONS_Tmp2_g0_valid2_a1,
      CONDITIONS_Tmp2_g0_valid2_a2,
      CONDITIONS_Tmp2_g0_valid2_a3;

// For |conditions>tmp2$in.
logic w_CONDITIONS_Tmp2_in_a1,
      CONDITIONS_Tmp2_in_a2,
      CONDITIONS_Tmp2_in_a3;

// For |conditions>tmp2$valid2.
logic CONDITIONS_Tmp2_valid2_a1;

// For |test$foo.
logic TEST_foo_a0;


//
// Scope: >core[1:0]
//

//
// Scope: >core>inst[3:0]
//

//
// Scope: >core>inst|pipe1
//

// Clock signals.
logic clkP_Core_Inst_PIPE1_valid_a4 [1:0][3:0];
logic clkP_Core_Inst_PIPE1_valid_a5 [1:0][3:0];

//
// Scope: |conditions
//

//
// Scope: |conditions>tmp2
//

// Clock signals.
logic clkP_CONDITIONS_Tmp2_g0_valid2_a2 ;
logic clkP_CONDITIONS_Tmp2_g0_valid2_a3 ;



   //
   // Scope: >core[1:0]
   //
   for (core = 0; core <= 1; core++) begin : L1gen_Core

      //
      // Scope: >inst[3:0]
      //
      for (inst = 0; inst <= 3; inst++) begin : L2gen_Inst

         //
         // Scope: |pipe1
         //

            // Staging of signal $imm_data, which had no assignment.
            assign Core_Inst_PIPE1_imm_data_a3[core][inst] = 'x;

            // Staging of $op_a.
            always_ff @(posedge clkP_Core_Inst_PIPE1_valid_a4[core][inst]) L1_Core[core].L2_Inst[inst].L2_PIPE1_op_a_a4[63:0] <= L1_Core[core].L2_Inst[inst].w_L2_PIPE1_op_a_a3[63:0];

            // Staging of signal $op_a_src, which had no assignment.
            assign Core_Inst_PIPE1_op_a_src_a3[core][inst] = 'x;

            // Staging of signal $op_b, which had no assignment.
            assign Core_Inst_PIPE1_op_b_a4[core][inst] = 'x;

            // Staging of signal $opcode, which had no assignment.
            assign Core_Inst_PIPE1_opcode_a4[core][inst] = 'x;

            // Staging of $rslt.
            always_ff @(posedge clkP_Core_Inst_PIPE1_valid_a5[core][inst]) L1_Core[core].L2_Inst[inst].L2_PIPE1_rslt_a5[63:0] <= L1_Core[core].L2_Inst[inst].L2_PIPE1_rslt_a4[63:0];

            // Staging of $valid.
            always_ff @(posedge clk) L1_Core[core].L1_Inst_PIPE1_valid_a2[inst] <= L1_Core[core].L1_Inst_PIPE1_valid_a1[inst];
            always_ff @(posedge clk) L1_Core[core].L1_Inst_PIPE1_valid_a3[inst] <= L1_Core[core].L1_Inst_PIPE1_valid_a2[inst];
            always_ff @(posedge clk) L1_Core[core].L1_Inst_PIPE1_valid_a4[inst] <= L1_Core[core].L1_Inst_PIPE1_valid_a3[inst];
            always_ff @(posedge clk) L1_Core[core].L1_Inst_PIPE1_valid_a5[inst] <= L1_Core[core].L1_Inst_PIPE1_valid_a4[inst];



         //
         // Scope: |pipe2
         //

            // Staging of $rslt.
            always_ff @(posedge clk) L1_Core[core].L2_Inst[inst].L2_PIPE2_rslt_a6[63:0] <= L1_Core[core].L2_Inst[inst].L2_PIPE2_rslt_a5[63:0];


      end
   end

   //
   // Scope: >it
   //

      // Staging of signal $bar, which had no assignment.
      assign It_bar_a0 = 'x;



   //
   // Scope: |conditions
   //


      //
      // Scope: >tmp2
      //

         // Staging of an unconditioned version of a condition signal.
         assign CONDITIONS_Tmp2_g0_valid2_a1 = CONDITIONS_Tmp2_valid2_a1 && CONDITIONS_valid1_a1;
         always_ff @(posedge clk) CONDITIONS_Tmp2_g0_valid2_a2 <= CONDITIONS_Tmp2_g0_valid2_a1;
         always_ff @(posedge clk) CONDITIONS_Tmp2_g0_valid2_a3 <= CONDITIONS_Tmp2_g0_valid2_a2;

         // Staging of $in.
         always_ff @(posedge clkP_CONDITIONS_Tmp2_g0_valid2_a2) CONDITIONS_Tmp2_in_a2 <= w_CONDITIONS_Tmp2_in_a1;
         always_ff @(posedge clkP_CONDITIONS_Tmp2_g0_valid2_a3) CONDITIONS_Tmp2_in_a3 <= CONDITIONS_Tmp2_in_a2;






//
// Gated clocks.
//



   //
   // Scope: >core[1:0]
   //
   for (core = 0; core <= 1; core++) begin : L1clk_Core

      //
      // Scope: >inst[3:0]
      //
      for (inst = 0; inst <= 3; inst++) begin : L2clk_Inst

         //
         // Scope: |pipe1
         //

            clk_gate gen_clkP_Core_Inst_PIPE1_valid_a4(clkP_Core_Inst_PIPE1_valid_a4[core][inst], clk, 1'b1, L1_Core[core].L1_Inst_PIPE1_valid_a3[inst], 1'b0);
            clk_gate gen_clkP_Core_Inst_PIPE1_valid_a5(clkP_Core_Inst_PIPE1_valid_a5[core][inst], clk, 1'b1, L1_Core[core].L1_Inst_PIPE1_valid_a4[inst], 1'b0);

      end
   end

   //
   // Scope: |conditions
   //


      //
      // Scope: >tmp2
      //

         clk_gate gen_clkP_CONDITIONS_Tmp2_g0_valid2_a2(clkP_CONDITIONS_Tmp2_g0_valid2_a2, clk, 1'b1, CONDITIONS_Tmp2_g0_valid2_a1, 1'b0);
         clk_gate gen_clkP_CONDITIONS_Tmp2_g0_valid2_a3(clkP_CONDITIONS_Tmp2_g0_valid2_a3, clk, 1'b1, CONDITIONS_Tmp2_g0_valid2_a2, 1'b0);




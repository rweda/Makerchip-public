// Generated by SandPiper(TM).
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


genvar hier;


//
// Signals declared top-level.
//

// For |pipe$State.
logic [7:0] w_PIPE_State_a1 /* without recirculation for "when" condition */;
logic [7:0] PIPE_State_a1;
logic [7:0] PIPE_State_a2;
logic [7:0] PIPE_State_a3;
logic [7:0] PIPE_State_a4;

// For |pipe$bar.
logic [7:0] PIPE_bar_a4;

// For |pipe$cnt.
logic [7:0] PIPE_cnt_a0;
logic [7:0] PIPE_cnt_a1;
logic [7:0] PIPE_cnt_a2;
logic [7:0] PIPE_cnt_a3;
logic [7:0] PIPE_cnt_a4;

// For |pipe$reset.
logic PIPE_reset_a0;
logic PIPE_reset_a1;
logic PIPE_reset_a2;
logic PIPE_reset_a3;
logic PIPE_reset_a4;

// For |pipe$valid.
logic PIPE_valid_a0;
logic PIPE_valid_a1;
logic PIPE_valid_a2;
logic PIPE_valid_a3;
logic PIPE_valid_a4;

// For |pipe$valid2.
logic PIPE_valid2_a0;
logic PIPE_valid2_a1;
logic PIPE_valid2_a2;
logic PIPE_valid2_a3;
logic PIPE_valid2_a4;

// For |pipe/hier$failed.
logic [1:0] PIPE_Hier_failed_a4;

// For |pipe/hier$g0_valid2.
logic PIPE_Hier_g0_valid2_a4 [1:0];

// For |pipe2$State.
logic w_PIPE2_State_n1 /* without recirculation for "when" condition */;
logic PIPE2_State_n1;
logic PIPE2_State_a0;

// For |pipe2$bob.
logic PIPE2_bob_a0;

// For |pipe2$odd.
logic PIPE2_odd_a0;
logic PIPE2_odd_a1;
logic PIPE2_odd_a2;
logic PIPE2_odd_a3;

// For |pipe2/copy$Five.
logic [7:0] w_PIPE2_Copy_Five_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Five_a2;
logic [7:0] PIPE2_Copy_Five_a3;

// For |pipe2/copy$Four.
logic [7:0] w_PIPE2_Copy_Four_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Four_a2;
logic [7:0] PIPE2_Copy_Four_a3;

// For |pipe2/copy$One.
logic [7:0] w_PIPE2_Copy_One_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_One_a2;
logic [7:0] PIPE2_Copy_One_a3;

// For |pipe2/copy$Seven.
logic [7:0] w_PIPE2_Copy_Seven_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Seven_a2;
logic [7:0] PIPE2_Copy_Seven_a3;

// For |pipe2/copy$Six.
logic [7:0] w_PIPE2_Copy_Six_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Six_a2;
logic [7:0] PIPE2_Copy_Six_a3;

// For |pipe2/copy$Three.
logic [7:0] w_PIPE2_Copy_Three_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Three_a2;
logic [7:0] PIPE2_Copy_Three_a3;

// For |pipe2/copy$Two.
logic [7:0] w_PIPE2_Copy_Two_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Two_a2;
logic [7:0] PIPE2_Copy_Two_a3;

// For |pipe2/copy$bob.
logic PIPE2_Copy_bob_a0;

// For |pipe2/copy$eight.
logic [7:0] PIPE2_Copy_eight_a3;




   //
   // Scope: |pipe
   //

      // Update state with next state or hold.
      assign PIPE_State_a1 = !PIPE_valid_a2 ? PIPE_State_a2[7:0] : w_PIPE_State_a1;
      // Staging of $State.
      always_ff @(posedge clk) PIPE_State_a2[7:0] <= PIPE_State_a1[7:0];
      always_ff @(posedge clk) PIPE_State_a3[7:0] <= PIPE_State_a2[7:0];
      always_ff @(posedge clk) PIPE_State_a4[7:0] <= PIPE_State_a3[7:0];

      // Staging of $cnt.
      always_ff @(posedge clk) PIPE_cnt_a1[7:0] <= PIPE_cnt_a0[7:0];
      always_ff @(posedge clk) PIPE_cnt_a2[7:0] <= PIPE_cnt_a1[7:0];
      always_ff @(posedge clk) PIPE_cnt_a3[7:0] <= PIPE_cnt_a2[7:0];
      always_ff @(posedge clk) PIPE_cnt_a4[7:0] <= PIPE_cnt_a3[7:0];

      // Staging of $reset.
      always_ff @(posedge clk) PIPE_reset_a1 <= PIPE_reset_a0;
      always_ff @(posedge clk) PIPE_reset_a2 <= PIPE_reset_a1;
      always_ff @(posedge clk) PIPE_reset_a3 <= PIPE_reset_a2;
      always_ff @(posedge clk) PIPE_reset_a4 <= PIPE_reset_a3;

      // Staging of $valid.
      always_ff @(posedge clk) PIPE_valid_a1 <= PIPE_valid_a0;
      always_ff @(posedge clk) PIPE_valid_a2 <= PIPE_valid_a1;
      always_ff @(posedge clk) PIPE_valid_a3 <= PIPE_valid_a2;
      always_ff @(posedge clk) PIPE_valid_a4 <= PIPE_valid_a3;

      // Staging of $valid2.
      always_ff @(posedge clk) PIPE_valid2_a1 <= PIPE_valid2_a0;
      always_ff @(posedge clk) PIPE_valid2_a2 <= PIPE_valid2_a1;
      always_ff @(posedge clk) PIPE_valid2_a3 <= PIPE_valid2_a2;
      always_ff @(posedge clk) PIPE_valid2_a4 <= PIPE_valid2_a3;


      //
      // Scope: /hier[1:0]
      //
      for (hier = 0; hier <= 1; hier++) begin : L1gen_PIPE_Hier
         // Update state with next state or hold.
         assign L1_PIPE_Hier[hier].L1_Cnt_a3 = !PIPE_Hier_g0_valid2_a4[hier] ? L1_PIPE_Hier[hier].L1_Cnt_a4[7:0] : L1_PIPE_Hier[hier].w_L1_Cnt_a3;
         // Staging of $Cnt.
         always_ff @(posedge clk) L1_PIPE_Hier[hier].L1_Cnt_a4[7:0] <= L1_PIPE_Hier[hier].L1_Cnt_a3[7:0];

         // Update state with next state or hold.
         assign L1_PIPE_Hier[hier].L1_Foo_a3 = !PIPE_Hier_g0_valid2_a4[hier] ? L1_PIPE_Hier[hier].L1_Foo_a4[7:0] : L1_PIPE_Hier[hier].w_L1_Foo_a3;
         // Staging of $Foo.
         always_ff @(posedge clk) L1_PIPE_Hier[hier].L1_Foo_a4[7:0] <= L1_PIPE_Hier[hier].L1_Foo_a3[7:0];

         // Staging of an unconditioned version of a condition signal.
         assign PIPE_Hier_g0_valid2_a4[hier] = L1_PIPE_Hier[hier].L1_valid2_a4 && PIPE_valid_a4;

      end


   //
   // Scope: |pipe2
   //

      // Update state with next state or hold.
      assign PIPE2_State_n1 = !PIPE2_odd_a0 ? PIPE2_State_a0 : w_PIPE2_State_n1;
      // Staging of $State.
      always_ff @(posedge clk) PIPE2_State_a0 <= PIPE2_State_n1;

      // Staging of $odd.
      always_ff @(posedge clk) PIPE2_odd_a1 <= PIPE2_odd_a0;
      always_ff @(posedge clk) PIPE2_odd_a2 <= PIPE2_odd_a1;
      always_ff @(posedge clk) PIPE2_odd_a3 <= PIPE2_odd_a2;


      //
      // Scope: /copy
      //

         // Update state with next state or hold.
         assign PIPE2_Copy_Five_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Five_a3[7:0] : w_PIPE2_Copy_Five_a2;
         // Staging of $Five.
         always_ff @(posedge clk) PIPE2_Copy_Five_a3[7:0] <= PIPE2_Copy_Five_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Four_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Four_a3[7:0] : w_PIPE2_Copy_Four_a2;
         // Staging of $Four.
         always_ff @(posedge clk) PIPE2_Copy_Four_a3[7:0] <= PIPE2_Copy_Four_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_One_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_One_a3[7:0] : w_PIPE2_Copy_One_a2;
         // Staging of $One.
         always_ff @(posedge clk) PIPE2_Copy_One_a3[7:0] <= PIPE2_Copy_One_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Seven_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Seven_a3[7:0] : w_PIPE2_Copy_Seven_a2;
         // Staging of $Seven.
         always_ff @(posedge clk) PIPE2_Copy_Seven_a3[7:0] <= PIPE2_Copy_Seven_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Six_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Six_a3[7:0] : w_PIPE2_Copy_Six_a2;
         // Staging of $Six.
         always_ff @(posedge clk) PIPE2_Copy_Six_a3[7:0] <= PIPE2_Copy_Six_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Three_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Three_a3[7:0] : w_PIPE2_Copy_Three_a2;
         // Staging of $Three.
         always_ff @(posedge clk) PIPE2_Copy_Three_a3[7:0] <= PIPE2_Copy_Three_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Two_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Two_a3[7:0] : w_PIPE2_Copy_Two_a2;
         // Staging of $Two.
         always_ff @(posedge clk) PIPE2_Copy_Two_a3[7:0] <= PIPE2_Copy_Two_a2[7:0];





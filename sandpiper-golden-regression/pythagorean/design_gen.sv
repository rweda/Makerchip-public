// Generated by SandPiper(TM).
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


// For X injection on assignments, disableable using `define SP_PHYS.
`ifdef WHEN
   $warning("WHEN macro redefined.");
`endif
`ifdef SP_PHYS
   `define WHEN(valid_sig)
`else
   `define WHEN(valid_sig) !valid_sig ? 'x :
`endif


genvar entry;


//
// Signals declared top-level.
//

// For |calc$CycCnt.
logic [15:0] CALC_CycCnt_n1;
logic [15:0] CALC_CycCnt_a0;
logic [15:0] CALC_CycCnt_a1;
logic [15:0] CALC_CycCnt_a2;
logic [15:0] CALC_CycCnt_a3;
logic [15:0] CALC_CycCnt_a4;
logic [15:0] CALC_CycCnt_a5;

// For |calc$TotDist.
logic [31:0] w_CALC_TotDist_a4;
logic [31:0] CALC_TotDist_a5;

// For |calc$aa.
logic [31:0] w_CALC_aa_a0 /* without X injection for "when" condition */;
logic [31:0] CALC_aa_a0;
logic [31:0] CALC_aa_a1;
logic [31:0] CALC_aa_a2;
logic [31:0] CALC_aa_a3;
logic [31:0] CALC_aa_a4;
logic [31:0] CALC_aa_a5;

// For |calc$aa_squared.
logic [31:0] w_CALC_aa_squared_a1;
logic [31:0] CALC_aa_squared_a2;

// For |calc$bb.
logic [31:0] w_CALC_bb_a0;
logic [31:0] CALC_bb_a1;
logic [31:0] CALC_bb_a2;
logic [31:0] CALC_bb_a3;
logic [31:0] CALC_bb_a4;
logic [31:0] CALC_bb_a5;

// For |calc$bb_squared.
logic [31:0] w_CALC_bb_squared_a1;
logic [31:0] CALC_bb_squared_a2;

// For |calc$blocked.
logic CALC_blocked_a0;

// For |calc$cc.
logic [31:0] w_CALC_cc_a3;
logic [31:0] CALC_cc_a4;
logic [31:0] CALC_cc_a5;

// For |calc$cc_squared.
logic [31:0] w_CALC_cc_squared_a2;
logic [31:0] CALC_cc_squared_a3;

// For |calc$corrected_aa.
logic [31:0] w_CALC_corrected_aa_a0;
logic [31:0] CALC_corrected_aa_a1;
logic [31:0] CALC_corrected_aa_a2;
logic [31:0] CALC_corrected_aa_a3;
logic [31:0] CALC_corrected_aa_a4;
logic [31:0] CALC_corrected_aa_a5;

// For |calc$reset.
logic CALC_reset_a0;
logic CALC_reset_a1;
logic CALC_reset_a2;
logic CALC_reset_a3;
logic CALC_reset_a4;

// For |calc$skip_to.
logic w_CALC_skip_to_a0 /* without X injection for "when" condition */;
logic CALC_skip_to_a0;
logic CALC_skip_to_a1;
logic CALC_skip_to_a2;
logic CALC_skip_to_a3;
logic CALC_skip_to_a4;
logic CALC_skip_to_a5;

// For |calc$too_big.
logic w_CALC_too_big_a5 /* without X injection for "when" condition */;
logic CALC_too_big_a5;

// For |calc$too_small.
logic w_CALC_too_small_a5 /* without X injection for "when" condition */;
logic CALC_too_small_a5;

// For |calc$tot_incr.
logic [31:0] w_CALC_tot_incr_a4 /* without X injection for "when" condition */;
logic [31:0] CALC_tot_incr_a4;

// For |calc$trans_avail.
logic CALC_trans_avail_a0;

// For |calc$trans_valid.
logic CALC_trans_valid_a0;
logic CALC_trans_valid_a1;
logic CALC_trans_valid_a2;
logic CALC_trans_valid_a3;
logic CALC_trans_valid_a4;

// For |calc$valid.
logic CALC_valid_a0;
logic CALC_valid_a1;
logic CALC_valid_a2;
logic CALC_valid_a3;
logic CALC_valid_a4;
logic CALC_valid_a5;

// For |calc$valid_or_reset.
logic CALC_valid_or_reset_a0;
logic CALC_valid_or_reset_a1;
logic CALC_valid_or_reset_a2;
logic CALC_valid_or_reset_a3;
logic CALC_valid_or_reset_a4;

// For |calc>entry>accum$aa.
logic [31:0] CALC_Entry_Accum_aa_a0 [(5)-1:0];

// For |calc>entry>accum$bb.
logic [31:0] CALC_Entry_Accum_bb_a0 [(5)-1:0];

// For |calc>entry>accum$skip_to.
logic CALC_Entry_Accum_skip_to_a0 [(5)-1:0];

// For |calc>fifo_head$aa.
logic [31:0] w_CALC_FifoHead_aa_a0 /* without X injection for "when" condition */;
logic [31:0] CALC_FifoHead_aa_a0;

// For |calc>fifo_head$bb.
logic [31:0] w_CALC_FifoHead_bb_a0 /* without X injection for "when" condition */;
logic [31:0] CALC_FifoHead_bb_a0;

// For |calc>fifo_head$skip_to.
logic w_CALC_FifoHead_skip_to_a0 /* without X injection for "when" condition */;
logic CALC_FifoHead_skip_to_a0;

// For |calc>fifo_head$trans_avail.
logic CALC_FifoHead_trans_avail_a0;

// For |calc>head$aa.
logic [31:0] w_CALC_Head_aa_a0 /* without X injection for "when" condition */;
logic [31:0] CALC_Head_aa_a0;

// For |calc>head$bb.
logic [31:0] w_CALC_Head_bb_a0 /* without X injection for "when" condition */;
logic [31:0] CALC_Head_bb_a0;

// For |calc>head$skip_to.
logic w_CALC_Head_skip_to_a0 /* without X injection for "when" condition */;
logic CALC_Head_skip_to_a0;

// For |calc>head$trans_avail.
logic CALC_Head_trans_avail_a0;

// For |in$aa.
logic [31:0] w_IN_aa_a0 /* without X injection for "when" condition */;
logic [31:0] IN_aa_a0;

// For |in$bb.
logic [31:0] w_IN_bb_a0 /* without X injection for "when" condition */;
logic [31:0] IN_bb_a0;

// For |in$blocked.
logic IN_blocked_a0;

// For |in$bypass.
logic IN_bypass_a0;

// For |in$empty.
logic IN_empty_a1;

// For |in$full.
logic IN_full_a1;

// For |in$grow.
logic IN_grow_a0;

// For |in$out_blocked.
logic IN_out_blocked_a0;

// For |in$push.
logic IN_push_a0;

// For |in$rand_aa.
logic [14:0] w_IN_rand_aa_a0 /* without X injection for "when" condition */;
logic [14:0] IN_rand_aa_a0;

// For |in$rand_bb.
logic [14:0] w_IN_rand_bb_a0 /* without X injection for "when" condition */;
logic [14:0] IN_rand_bb_a0;

// For |in$rand_skip_to.
logic [0:0] IN_rand_skip_to_a0;

// For |in$rand_valid.
logic [0:0] IN_rand_valid_a0;

// For |in$reset.
logic IN_reset_a0;

// For |in$shrink.
logic IN_shrink_a0;

// For |in$skip_to.
logic IN_skip_to_a0;

// For |in$trans_avail.
logic IN_trans_avail_a0;

// For |in$trans_valid.
logic IN_trans_valid_a0;

// For |in$two_valid.
logic IN_two_valid_a0;
logic IN_two_valid_a1;

// For |in$valid.
logic IN_valid_a0;
logic IN_valid_a1;

// For |in$valid_count.
logic [$clog2((5)+1)-1:0] IN_valid_count_a0;
logic [$clog2((5)+1)-1:0] IN_valid_count_a1;

// For |in$would_bypass.
logic IN_would_bypass_a0;

// For |in>entry$State.
logic IN_Entry_State_a0 [(5)-1:0];
logic IN_Entry_State_a1 [(5)-1:0];

// For |in>entry$prev_entry_was_tail.
logic [(5)-1:0] IN_Entry_prev_entry_was_tail_a0;

// For |in>entry$push.
logic [(5)-1:0] IN_Entry_push_a0;

// For |in>entry$reconstructed_is_tail.
logic [(5)-1:0] IN_Entry_reconstructed_is_tail_a1;

// For |reset$reset.
logic RESET_reset_n1;
logic RESET_reset_a0;


//
// Scope: |calc
//

// Clock signals.
logic clkF_CALC_valid_or_reset_a5 ;
logic clkP_CALC_trans_valid_a1 ;
logic clkP_CALC_trans_valid_a2 ;
logic clkP_CALC_trans_valid_a3 ;
logic clkP_CALC_trans_valid_a4 ;
logic clkP_CALC_trans_valid_a5 ;
logic clkP_CALC_valid_a1 ;
logic clkP_CALC_valid_a2 ;
logic clkP_CALC_valid_a3 ;
logic clkP_CALC_valid_a4 ;
logic clkP_CALC_valid_a5 ;



   //
   // Scope: |calc
   //

      // Staging of $CycCnt.
      always_ff @(posedge clk) CALC_CycCnt_a0[15:0] <= CALC_CycCnt_n1[15:0];
      always_ff @(posedge clk) CALC_CycCnt_a1[15:0] <= CALC_CycCnt_a0[15:0];
      always_ff @(posedge clk) CALC_CycCnt_a2[15:0] <= CALC_CycCnt_a1[15:0];
      always_ff @(posedge clk) CALC_CycCnt_a3[15:0] <= CALC_CycCnt_a2[15:0];
      always_ff @(posedge clk) CALC_CycCnt_a4[15:0] <= CALC_CycCnt_a3[15:0];
      always_ff @(posedge clk) CALC_CycCnt_a5[15:0] <= CALC_CycCnt_a4[15:0];

      // Staging of $TotDist.
      always_ff @(posedge clkF_CALC_valid_or_reset_a5) CALC_TotDist_a5[31:0] <= w_CALC_TotDist_a4[31:0];

      // Inject X when invalid.
      assign CALC_aa_a0 = `WHEN(CALC_trans_valid_a0) w_CALC_aa_a0;
      // Staging of $aa.
      always_ff @(posedge clkP_CALC_trans_valid_a1) CALC_aa_a1[31:0] <= CALC_aa_a0[31:0];
      always_ff @(posedge clkP_CALC_trans_valid_a2) CALC_aa_a2[31:0] <= CALC_aa_a1[31:0];
      always_ff @(posedge clkP_CALC_trans_valid_a3) CALC_aa_a3[31:0] <= CALC_aa_a2[31:0];
      always_ff @(posedge clkP_CALC_trans_valid_a4) CALC_aa_a4[31:0] <= CALC_aa_a3[31:0];
      always_ff @(posedge clkP_CALC_trans_valid_a5) CALC_aa_a5[31:0] <= CALC_aa_a4[31:0];

      // Staging of $aa_squared.
      always_ff @(posedge clkP_CALC_valid_a2) CALC_aa_squared_a2[31:0] <= w_CALC_aa_squared_a1[31:0];

      // Staging of $bb.
      always_ff @(posedge clkP_CALC_trans_valid_a1) CALC_bb_a1[31:0] <= w_CALC_bb_a0[31:0];
      always_ff @(posedge clkP_CALC_trans_valid_a2) CALC_bb_a2[31:0] <= CALC_bb_a1[31:0];
      always_ff @(posedge clkP_CALC_trans_valid_a3) CALC_bb_a3[31:0] <= CALC_bb_a2[31:0];
      always_ff @(posedge clkP_CALC_trans_valid_a4) CALC_bb_a4[31:0] <= CALC_bb_a3[31:0];
      always_ff @(posedge clkP_CALC_trans_valid_a5) CALC_bb_a5[31:0] <= CALC_bb_a4[31:0];

      // Staging of $bb_squared.
      always_ff @(posedge clkP_CALC_valid_a2) CALC_bb_squared_a2[31:0] <= w_CALC_bb_squared_a1[31:0];

      // Staging of $cc.
      always_ff @(posedge clkP_CALC_valid_a4) CALC_cc_a4[31:0] <= w_CALC_cc_a3[31:0];
      always_ff @(posedge clkP_CALC_valid_a5) CALC_cc_a5[31:0] <= CALC_cc_a4[31:0];

      // Staging of $cc_squared.
      always_ff @(posedge clkP_CALC_valid_a3) CALC_cc_squared_a3[31:0] <= w_CALC_cc_squared_a2[31:0];

      // Staging of $corrected_aa.
      always_ff @(posedge clkP_CALC_valid_a1) CALC_corrected_aa_a1[31:0] <= w_CALC_corrected_aa_a0[31:0];
      always_ff @(posedge clkP_CALC_valid_a2) CALC_corrected_aa_a2[31:0] <= CALC_corrected_aa_a1[31:0];
      always_ff @(posedge clkP_CALC_valid_a3) CALC_corrected_aa_a3[31:0] <= CALC_corrected_aa_a2[31:0];
      always_ff @(posedge clkP_CALC_valid_a4) CALC_corrected_aa_a4[31:0] <= CALC_corrected_aa_a3[31:0];
      always_ff @(posedge clkP_CALC_valid_a5) CALC_corrected_aa_a5[31:0] <= CALC_corrected_aa_a4[31:0];

      // Staging of $reset.
      always_ff @(posedge clk) CALC_reset_a1 <= CALC_reset_a0;
      always_ff @(posedge clk) CALC_reset_a2 <= CALC_reset_a1;
      always_ff @(posedge clk) CALC_reset_a3 <= CALC_reset_a2;
      always_ff @(posedge clk) CALC_reset_a4 <= CALC_reset_a3;

      // Inject X when invalid.
      assign CALC_skip_to_a0 = `WHEN(CALC_trans_valid_a0) w_CALC_skip_to_a0;
      // Staging of $skip_to.
      always_ff @(posedge clkP_CALC_trans_valid_a1) CALC_skip_to_a1 <= CALC_skip_to_a0;
      always_ff @(posedge clkP_CALC_trans_valid_a2) CALC_skip_to_a2 <= CALC_skip_to_a1;
      always_ff @(posedge clkP_CALC_trans_valid_a3) CALC_skip_to_a3 <= CALC_skip_to_a2;
      always_ff @(posedge clkP_CALC_trans_valid_a4) CALC_skip_to_a4 <= CALC_skip_to_a3;
      always_ff @(posedge clkP_CALC_trans_valid_a5) CALC_skip_to_a5 <= CALC_skip_to_a4;

      // Inject X when invalid.
      assign CALC_too_big_a5 = `WHEN(CALC_valid_a5) w_CALC_too_big_a5;
      // Inject X when invalid.
      assign CALC_too_small_a5 = `WHEN(CALC_valid_a5) w_CALC_too_small_a5;
      // Inject X when invalid.
      assign CALC_tot_incr_a4 = `WHEN(CALC_valid_a4) w_CALC_tot_incr_a4;
      // Staging of $trans_valid.
      always_ff @(posedge clk) CALC_trans_valid_a1 <= CALC_trans_valid_a0;
      always_ff @(posedge clk) CALC_trans_valid_a2 <= CALC_trans_valid_a1;
      always_ff @(posedge clk) CALC_trans_valid_a3 <= CALC_trans_valid_a2;
      always_ff @(posedge clk) CALC_trans_valid_a4 <= CALC_trans_valid_a3;

      // Staging of $valid.
      always_ff @(posedge clk) CALC_valid_a1 <= CALC_valid_a0;
      always_ff @(posedge clk) CALC_valid_a2 <= CALC_valid_a1;
      always_ff @(posedge clk) CALC_valid_a3 <= CALC_valid_a2;
      always_ff @(posedge clk) CALC_valid_a4 <= CALC_valid_a3;
      always_ff @(posedge clk) CALC_valid_a5 <= CALC_valid_a4;

      // Staging of $valid_or_reset.
      always_ff @(posedge clk) CALC_valid_or_reset_a1 <= CALC_valid_or_reset_a0;
      always_ff @(posedge clk) CALC_valid_or_reset_a2 <= CALC_valid_or_reset_a1;
      always_ff @(posedge clk) CALC_valid_or_reset_a3 <= CALC_valid_or_reset_a2;
      always_ff @(posedge clk) CALC_valid_or_reset_a4 <= CALC_valid_or_reset_a3;


      //
      // Scope: >fifo_head
      //

         // Inject X when invalid.
         assign CALC_FifoHead_aa_a0 = `WHEN(CALC_FifoHead_trans_avail_a0) w_CALC_FifoHead_aa_a0;
         // Inject X when invalid.
         assign CALC_FifoHead_bb_a0 = `WHEN(CALC_FifoHead_trans_avail_a0) w_CALC_FifoHead_bb_a0;
         // Inject X when invalid.
         assign CALC_FifoHead_skip_to_a0 = `WHEN(CALC_FifoHead_trans_avail_a0) w_CALC_FifoHead_skip_to_a0;


      //
      // Scope: >head
      //

         // Inject X when invalid.
         assign CALC_Head_aa_a0 = `WHEN(CALC_Head_trans_avail_a0) w_CALC_Head_aa_a0;
         // Inject X when invalid.
         assign CALC_Head_bb_a0 = `WHEN(CALC_Head_trans_avail_a0) w_CALC_Head_bb_a0;
         // Inject X when invalid.
         assign CALC_Head_skip_to_a0 = `WHEN(CALC_Head_trans_avail_a0) w_CALC_Head_skip_to_a0;



   //
   // Scope: |in
   //

      // Inject X when invalid.
      assign IN_aa_a0 = `WHEN(IN_valid_a0) w_IN_aa_a0;
      // Inject X when invalid.
      assign IN_bb_a0 = `WHEN(IN_valid_a0) w_IN_bb_a0;
      // Inject X when invalid.
      assign IN_rand_aa_a0 = `WHEN(IN_valid_a0) w_IN_rand_aa_a0;
      // Inject X when invalid.
      assign IN_rand_bb_a0 = `WHEN(IN_valid_a0) w_IN_rand_bb_a0;
      // Staging of $two_valid.
      always_ff @(posedge clk) IN_two_valid_a1 <= IN_two_valid_a0;

      // Staging of $valid.
      always_ff @(posedge clk) IN_valid_a1 <= IN_valid_a0;

      // Staging of $valid_count.
      always_ff @(posedge clk) IN_valid_count_a1[$clog2((5)+1)-1:0] <= IN_valid_count_a0[$clog2((5)+1)-1:0];


      //
      // Scope: >entry[(5)-1:0]
      //
      for (entry = 0; entry <= (5)-1; entry++) begin : L1gen_IN_Entry
         // Staging of $State.
         always_ff @(posedge clk) IN_Entry_State_a1[entry] <= IN_Entry_State_a0[entry];

         // Staging of $aa.
         always_ff @(posedge clk) L1d_IN_Entry[entry].L1_aa_a1[31:0] <= L1d_IN_Entry[entry].L1_aa_a0[31:0];

         // Staging of $bb.
         always_ff @(posedge clk) L1d_IN_Entry[entry].L1_bb_a1[31:0] <= L1d_IN_Entry[entry].L1_bb_a0[31:0];

         // Staging of $skip_to.
         always_ff @(posedge clk) L1d_IN_Entry[entry].L1_skip_to_a1 <= L1d_IN_Entry[entry].L1_skip_to_a0;

      end


   //
   // Scope: |reset
   //

      // Staging of $reset.
      always_ff @(posedge clk) RESET_reset_a0 <= RESET_reset_n1;





//
// Gated clocks.
//



   //
   // Scope: |calc
   //

      clk_gate gen_clkF_CALC_valid_or_reset_a5(clkF_CALC_valid_or_reset_a5, clk, CALC_valid_or_reset_a4, 1'b1, 1'b0);
      clk_gate gen_clkP_CALC_trans_valid_a1(clkP_CALC_trans_valid_a1, clk, 1'b1, (CALC_trans_valid_a0 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_CALC_trans_valid_a2(clkP_CALC_trans_valid_a2, clk, 1'b1, (CALC_trans_valid_a1 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_CALC_trans_valid_a3(clkP_CALC_trans_valid_a3, clk, 1'b1, (CALC_trans_valid_a2 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_CALC_trans_valid_a4(clkP_CALC_trans_valid_a4, clk, 1'b1, (CALC_trans_valid_a3 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_CALC_trans_valid_a5(clkP_CALC_trans_valid_a5, clk, 1'b1, (CALC_trans_valid_a4 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_CALC_valid_a1(clkP_CALC_valid_a1, clk, 1'b1, (CALC_valid_a0 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_CALC_valid_a2(clkP_CALC_valid_a2, clk, 1'b1, (CALC_valid_a1 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_CALC_valid_a3(clkP_CALC_valid_a3, clk, 1'b1, (CALC_valid_a2 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_CALC_valid_a4(clkP_CALC_valid_a4, clk, 1'b1, (CALC_valid_a3 ? 1'b1 : 1'bx), 1'b0);
      clk_gate gen_clkP_CALC_valid_a5(clkP_CALC_valid_a5, clk, 1'b1, (CALC_valid_a4 ? 1'b1 : 1'bx), 1'b0);



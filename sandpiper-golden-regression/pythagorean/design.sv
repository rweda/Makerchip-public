//_\TLV_version 1b: tl-x.org, generated by SandPiper(TM)

/*
Copyright (c) 2015, Steven F. Hoover

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * The name of Steven F. Hoover
      may not be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



// This example accumulates distance traveled in a series of hops.
// Hops are presented as $aa and $bb, a forward distance (along the line of the
// previous hop), and a sideways distance to
// the next target location.  If a new "skip-to" hop arrives next (and it must arrive
// precisely four cycles later), this hop's target is skipped and replaced by the
// destination provided in the skip-to hop (which is given relative to this target).
// The next hop (or skip-hop) is given relative to the corrected hop.

// The incoming stream of hops from the "Stimulus" code in this file are
// passed through a FIFO to be delivered into the pipeline.

module distance(input logic clk, logic reset, output logic passed, output logic failed);    bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_vect[256:0]); assign RW_rand_vect[256+63:257] = RW_rand_vect[62:0];

`include "design_gen.sv"

   //_|reset
      //_@-1
         // Create pipesignal out of reset module input.
         assign RESET_reset_n1 = reset;

   // Stimulus
   //_|in
      //_@0
         assign IN_rand_valid_a0[0:0] = RW_rand_vect[0 + (0) % 257 +: 1];
         assign IN_valid_a0 = IN_rand_valid_a0 && !IN_blocked_a0 && !RESET_reset_a0;
         assign IN_trans_avail_a0 = IN_valid_a0;
         assign IN_trans_valid_a0 = IN_trans_avail_a0;
         assign IN_rand_skip_to_a0[0:0] = RW_rand_vect[124 + (0) % 257 +: 1];
         assign IN_skip_to_a0 = IN_valid_a0 && IN_valid_a1 && IN_rand_skip_to_a0;
              // Only if last cycle generated a valid, so we know there's a hop to chase.
         //_?$valid
            assign w_IN_rand_aa_a0[14:0] = RW_rand_vect[248 + (0) % 257 +: 15];
            assign w_IN_rand_bb_a0[14:0] = RW_rand_vect[115 + (0) % 257 +: 15];
            assign w_IN_aa_a0[31:0] = {17'b0, IN_rand_aa_a0};
            assign w_IN_bb_a0[31:0] = {17'b0, IN_rand_bb_a0};
   
   // Input FIFO
   //_\source ./m4/1b/pipeflow_tlv.m4 414   // Instantiated from stdin, 69 as: m4+flop_fifo(top, in, 0, calc, 0, >top|reset$reset, 0, 5)
      //|default
      //   @0
      /*SV_plus*/
         localparam bit [$clog2((5)+1)-1:0] full_mark = 5;
      
      // FIFO Instantiation
      
      // Hierarchy declarations
      //_|in
         //_>entry
      //_|calc
         //_>entry
      
      // Hierarchy
      //_|in
         //_@0
            assign IN_reset_a0 = RESET_reset_a0;
            assign IN_out_blocked_a0 = CALC_blocked_a0;
            assign IN_blocked_a0 = IN_full_a1 && IN_out_blocked_a0;
            `BOGUS_USE(IN_blocked_a0)   // Not required to be consumed elsewhere.
            assign IN_would_bypass_a0 = IN_empty_a1;
            assign IN_bypass_a0 = IN_would_bypass_a0 && ! IN_out_blocked_a0;
            assign IN_push_a0 = IN_trans_valid_a0 && ! IN_bypass_a0;
            assign IN_grow_a0   =   IN_trans_valid_a0 &&   IN_out_blocked_a0;
            assign IN_shrink_a0 = ! IN_empty_a1 && ! IN_trans_avail_a0 && ! IN_out_blocked_a0;
            assign IN_valid_count_a0[$clog2((5)+1)-1:0] = IN_reset_a0 ? '0
                                                        : IN_valid_count_a1 + (
                                                             IN_grow_a0   ? { {($clog2((5)+1)-1){1'b0}}, 1'b1} :
                                                             IN_shrink_a0 ? '1
                                                                     : '0
                                                          );
            // At least 2 valid entries.
            //$two_valid = | $ValidCount[m4_counter_width-1:1];
            // but logic depth minimized by taking advantage of prev count >= 4.
            assign IN_two_valid_a0 = | IN_valid_count_a1[$clog2((5)+1)-1:2] || | IN_valid_count_a0[2:1];
            // These are an optimization of the commented block below to operate on vectors, rather than bits.
            // TODO: Keep optimizing...
            assign {IN_Entry_prev_entry_was_tail_a0} = {IN_Entry_reconstructed_is_tail_a1[3:0], IN_Entry_reconstructed_is_tail_a1[4]} /* circular << */;
            assign {IN_Entry_push_a0} = {5{IN_push_a0}} & IN_Entry_prev_entry_was_tail_a0;
            for (entry = 0; entry <= (5)-1; entry++) begin : L1b_IN_Entry logic L1_is_tail_a0; logic L1_valid_a0; //_>entry
               // Replaced with optimized versions above:
               // $prev_entry_was_tail = >entry[(entry+(m4_depth)-1)%(m4_depth)]$reconstructed_is_tail#+1;
               // $push = |m4_in_pipe$push && $prev_entry_was_tail;
               assign L1_valid_a0 = (L1c_IN_Entry[entry].L1_reconstructed_valid_a1 && ! L1b_CALC_Entry[entry].L1_pop_a0) || IN_Entry_push_a0[entry];
               assign L1_is_tail_a0 = IN_trans_valid_a0 ? IN_Entry_prev_entry_was_tail_a0[entry]  // shift tail
                                                  : IN_Entry_reconstructed_is_tail_a1[entry];  // retain tail
               assign IN_Entry_State_a0[entry] = IN_reset_a0 ? 1'b0
                                          : L1_valid_a0 && ! (IN_two_valid_a0 && L1_is_tail_a0); end
         //_@1
            assign IN_empty_a1 = ! IN_two_valid_a1 && ! IN_valid_count_a1[0];
            assign IN_full_a1 = (IN_valid_count_a1 == full_mark);  // Could optimize for power-of-two depth.
         for (entry = 0; entry <= (5)-1; entry++) begin : L1c_IN_Entry logic L1_is_head_a1; logic L1_next_entry_state_a1; logic L1_prev_entry_state_a1; logic L1_reconstructed_valid_a1; //_>entry
            //_@1
               assign L1_prev_entry_state_a1 = IN_Entry_State_a1[(entry+(5)-1)%(5)];
               assign L1_next_entry_state_a1 = IN_Entry_State_a1[(entry+1)%(5)];
               assign IN_Entry_reconstructed_is_tail_a1[entry] = (  IN_two_valid_a1 && (!IN_Entry_State_a1[entry] && L1_prev_entry_state_a1)) ||
                                        (! IN_two_valid_a1 && (!L1_next_entry_state_a1 && IN_Entry_State_a1[entry])) ||
                                        (IN_empty_a1 && (entry == 0));  // need a tail when empty for push
               assign L1_is_head_a1 = IN_Entry_State_a1[entry] && ! L1_prev_entry_state_a1;
               assign L1_reconstructed_valid_a1 = IN_Entry_State_a1[entry] || (IN_two_valid_a1 && L1_prev_entry_state_a1); end
      // Write data
      //_|in
         //_@0
            for (entry = 0; entry <= (5)-1; entry++) begin : L1d_IN_Entry logic [31:0] L1_aa_a0; logic [31:0] L1_aa_a1; logic [31:0] L1_bb_a0; logic [31:0] L1_bb_a1; logic L1_skip_to_a0; logic L1_skip_to_a1; //_>entry
               //?$push
               //   $aNY = |m4_in_pipe['']m4_trans_hier$ANY;
               assign {L1_aa_a0[31:0], L1_bb_a0[31:0], L1_skip_to_a0} = IN_Entry_push_a0[entry] ? {IN_aa_a0, IN_bb_a0, IN_skip_to_a0} : {L1_aa_a1, L1_bb_a1, L1_skip_to_a1} /* RETAIN */; end
      // Read data
      //_|calc
         //_@0
            //$pop  = ! >m4_top|m4_in_pipe$empty#m4_align(m4_in_at + 1, m4_out_at) && ! $blocked;
            for (entry = 0; entry <= (5)-1; entry++) begin : L1b_CALC_Entry logic L1_is_head_a0; logic L1_pop_a0; logic [31:0] L1_ReadMasked_aa_a0; logic [31:0] L1_ReadMasked_bb_a0; logic L1_ReadMasked_skip_to_a0; //_>entry
               assign L1_is_head_a0 = L1c_IN_Entry[entry].L1_is_head_a1;
               assign L1_pop_a0  = L1_is_head_a0 && ! CALC_blocked_a0;
               //_>read_masked
                  assign {L1_ReadMasked_aa_a0[31:0], L1_ReadMasked_bb_a0[31:0], L1_ReadMasked_skip_to_a0} = L1_is_head_a0 ? {L1d_IN_Entry[entry].L1_aa_a1, L1d_IN_Entry[entry].L1_bb_a1, L1d_IN_Entry[entry].L1_skip_to_a1} /* $aNY */ : '0;
               //_>accum
                  assign {CALC_Entry_Accum_aa_a0[entry][31:0], CALC_Entry_Accum_bb_a0[entry][31:0], CALC_Entry_Accum_skip_to_a0[entry]} = ((entry == 0) ? '0 : {CALC_Entry_Accum_aa_a0[(entry+(5)-1)%(5)], CALC_Entry_Accum_bb_a0[(entry+(5)-1)%(5)], CALC_Entry_Accum_skip_to_a0[(entry+(5)-1)%(5)]}) |
                             {L1_ReadMasked_aa_a0, L1_ReadMasked_bb_a0, L1_ReadMasked_skip_to_a0}; end
            //_>head
               assign CALC_Head_trans_avail_a0 = CALC_trans_avail_a0;
               //_?$trans_avail
                  assign {w_CALC_Head_aa_a0[31:0], w_CALC_Head_bb_a0[31:0], w_CALC_Head_skip_to_a0} = {CALC_Entry_Accum_aa_a0[(5)-1], CALC_Entry_Accum_bb_a0[(5)-1], CALC_Entry_Accum_skip_to_a0[(5)-1]};
      
      // Bypass
      //_|calc
         //_@0
            // Available output.  Sometimes it's necessary to know what would be coming to determined
            // if it's blocked.  This can be used externally in that case.
            //_>fifo_head
               assign CALC_FifoHead_trans_avail_a0 = CALC_trans_avail_a0;
               //_?$trans_avail
                  
                  assign {w_CALC_FifoHead_aa_a0[31:0], w_CALC_FifoHead_bb_a0[31:0], w_CALC_FifoHead_skip_to_a0} = IN_would_bypass_a0
                               ? {IN_aa_a0, IN_bb_a0, IN_skip_to_a0}
                               : {CALC_Head_aa_a0, CALC_Head_bb_a0, CALC_Head_skip_to_a0};
            assign CALC_trans_avail_a0 = ! IN_would_bypass_a0 || IN_trans_avail_a0;
            assign CALC_trans_valid_a0 = CALC_trans_avail_a0 && ! CALC_blocked_a0;
            //_?$trans_valid
               assign {w_CALC_aa_a0[31:0], w_CALC_bb_a0[31:0], w_CALC_skip_to_a0} = {CALC_FifoHead_aa_a0, CALC_FifoHead_bb_a0, CALC_FifoHead_skip_to_a0};
                            
                            
                            
      /* Alternate code for pointer indexing.  Replaces $ANY expression above.
      
      // Hierarchy
      |in
         >entry2[(5)-1:0]
      
      // Head/Tail ptrs.
      |in
         @0
            $NextWrPtr[\$clog2(5)-1:0] =
                $reset       ? '0 :
                $trans_valid ? ($NextWrPtr#+1 == (5 - 1))
                                 ? '0
                                 : $NextWrPtr#+1 + {{(\$clog2(5)-1){1'b0}}, 1'b1} :
                               $RETAIN;
      |calc
         @0
            $NextRdPtr[\$clog2(5)-1:0] =
                >top|in$reset#+0
                             ? '0 :
                $trans_valid ? ($NextRdPtr#+1 == (5 - 1))
                                 ? '0
                                 : $NextRdPtr#+1 + {{(\$clog2(5)-1){1'b0}}, 1'b1} :
                               $RETAIN;
      // Write FIFO
      |in
         @0
            $dummy = '0;
            ?$trans_valid
               // This doesn't work because SV complains for FIFOs in replicated context that
               // there are multiple procedures that assign the signals.
               // Array writes can be done in an SV module.
               // The only long-term resolutions are support for module generation and use
               // signals declared within for loops with cross-hierarchy references in SV.
               // TODO: To make a simulation-efficient FIFO, use DesignWare.
               {>entry2[$NextWrPtr#+1]$$ANY} = $ANY;
      // Read FIFO
      |calc
         @0
            >read2
               $trans_valid = |calc$trans_valid;
               ?$trans_valid
                  $ANY = >top|in>entry2[|calc$NextRdPtr#+1]$ANY#+0;
               `BOGUS_USE($dummy)
            ?$trans_valid
               $ANY = >read2$ANY;
      */
   //_\end_source

   //_|calc
      //_@0
         // Block corrections for 3 cycles.
         assign CALC_blocked_a0 = (CALC_trans_avail_a0 ? CALC_FifoHead_skip_to_a0 : 1'b1) && (CALC_valid_a1 || CALC_valid_a2 || CALC_valid_a3); 
         assign CALC_valid_a0 = CALC_trans_valid_a0;
         assign CALC_reset_a0 = RESET_reset_a0;
         assign CALC_valid_or_reset_a0 = CALC_valid_a0 || CALC_reset_a0;
      //_?$valid
         // DUT
         //_@0
            assign w_CALC_corrected_aa_a0[31:0] = CALC_skip_to_a0 ? (CALC_aa_a0 + CALC_cc_a4) : CALC_aa_a0;
         //_@++ (@1)
            assign w_CALC_aa_squared_a1[31:0] = CALC_corrected_aa_a1 * CALC_corrected_aa_a1;
            assign w_CALC_bb_squared_a1[31:0] = CALC_bb_a1 * CALC_bb_a1;
         //_@+=1 (@2)
            assign w_CALC_cc_squared_a2[31:0] = CALC_aa_squared_a2 + CALC_bb_squared_a2;
         //_@3
            assign w_CALC_cc_a3[31:0] = $sqrt(CALC_cc_squared_a3);
         //_@4
            assign w_CALC_tot_incr_a4[31:0] = CALC_TotDist_a5 + CALC_cc_a4;
      //_?$valid_or_reset
         //_@4
            assign w_CALC_TotDist_a4[31:0] =
                  CALC_reset_a4                            ? 32'b0     :  // reset
                  !(CALC_valid_a0 ? CALC_skip_to_a0 : 1'b0) ? CALC_tot_incr_a4 :  // add $cc
                                      CALC_TotDist_a5[31:0];                     // retain


         // Output.
      //_@5
         /*SV_plus*/
            always_ff @(posedge clk) begin
               if (CALC_valid_a5) begin
                  $display("Cyc %d:\n  $skip_to: %h\n  $aa: 0x%h\n  $bb: 0x%h\n  $cc: 0x%h\n  $TotDist: 0x%h\n", CALC_CycCnt_a5, CALC_skip_to_a5, CALC_aa_a5, CALC_bb_a5, CALC_cc_a5, CALC_TotDist_a5);
               end
            end

         //_?$valid
            // Checking
            // $cc cannot be less than either $corrected_aa or $bb, and
            // $cc cannot be greater than $corrected_aa + $bb.
            assign w_CALC_too_big_a5 = CALC_cc_a5 > (CALC_corrected_aa_a5 + CALC_bb_a5);
            assign w_CALC_too_small_a5 = (CALC_cc_a5 < CALC_corrected_aa_a5) || (CALC_cc_a5 < CALC_bb_a5);

         assign failed = CALC_valid_a5 ? CALC_too_big_a5 || CALC_too_small_a5 : 1'b0;

      //_@-1
         // Free-running cycle count.
         assign CALC_CycCnt_n1[15:0] = RESET_reset_n1 ? 16'b0 : CALC_CycCnt_a0 + 16'b1;

      //_@1
         // Pass the test on cycle 20.
         assign passed = CALC_CycCnt_a1 > 16'd20;
//_\SV
endmodule


// Undefine macros defined by SandPiper (in "design_gen.sv").
`undef BOGUS_USE
`undef WHEN

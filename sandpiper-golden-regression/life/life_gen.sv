// Generated by SandPiper(TM).
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


`include "sandpiper_gen.vh"


genvar xx, yy;


//
// Signals declared top-level.
//

// For |life$StartOk.
wire LIFE_StartOk_a0;
reg  LIFE_StartOk_a1;

// For |life$StopCnt.
wire [7:0] LIFE_StopCnt_a0;
reg  [7:0] LIFE_StopCnt_a1;

// For |life$above_min_start.
wire LIFE_above_min_start_a1;

// For |life$alive_cnt.
wire [21:0] LIFE_alive_cnt_a1;

// For |life$below_max_stop.
wire LIFE_below_max_stop_a1;

// For |life$reset.
wire LIFE_reset_a0;
reg  LIFE_reset_a1;

// For |life>yy$below_alive_accum.
wire [21:0] LIFE_Yy_below_alive_accum_a1 [Y_SIZE-1:0];

// For |life>yy>xx$right_alive_accum.
wire [10:0] LIFE_Yy_Xx_right_alive_accum_a1 [Y_SIZE-1:0][X_SIZE-1:0];




   //
   // Scope: |life
   //
   generate if (1) begin : L1gen_LIFE
      // Staging of $StartOk.
      always @(posedge clk) LIFE_StartOk_a1 <= LIFE_StartOk_a0;

      // Staging of $StopCnt.
      always @(posedge clk) LIFE_StopCnt_a1[7:0] <= LIFE_StopCnt_a0[7:0];

      // Staging of $reset.
      always @(posedge clk) LIFE_reset_a1 <= LIFE_reset_a0;


      //
      // Scope: >yy[Y_SIZE-1:0]
      //
      for (yy = 0; yy <= Y_SIZE-1; yy=yy+1) begin : L2gen_Yy

         //
         // Scope: >xx[X_SIZE-1:0]
         //
         for (xx = 0; xx <= X_SIZE-1; xx=xx+1) begin : L3gen_Xx
            // Staging of $Alive.
            always @(posedge clk) L1_LIFE.L1_Yy_Xx_Alive_a1[yy][xx] <= L1_LIFE.L1_Yy_Xx_Alive_a0[yy][xx];

            // Staging of $reset.
            always @(posedge clk) L1_LIFE.L2_Yy[yy].L3_Xx[xx].L3_reset_a1 <= L1_LIFE.L2_Yy[yy].L3_Xx[xx].L3_reset_a0;

         end
      end
   end endgenerate




//
// Debug Signals
//

generate

   if (1) begin : DEBUG_SIGS


      //
      // Scope: |life
      //
      if (1) begin : \|life 
         wire  \@0$StartOk ;
         assign \@0$StartOk = LIFE_StartOk_a0;
         wire [7:0] \@0$StopCnt ;
         assign \@0$StopCnt = LIFE_StopCnt_a0;
         wire  \@1$above_min_start ;
         assign \@1$above_min_start = LIFE_above_min_start_a1;
         wire [21:0] \@1$alive_cnt ;
         assign \@1$alive_cnt = LIFE_alive_cnt_a1;
         wire  \@1$below_max_stop ;
         assign \@1$below_max_stop = LIFE_below_max_stop_a1;
         wire  \@0$reset ;
         assign \@0$reset = LIFE_reset_a0;

         //
         // Scope: >yy[Y_SIZE-1:0]
         //
         for (yy = 0; yy <= Y_SIZE-1; yy=yy+1) begin : \>yy 
            wire [21:0] \@1$below_alive_accum ;
            assign \@1$below_alive_accum = LIFE_Yy_below_alive_accum_a1[yy];
            wire [21:0] \@1$vert_alive_accum ;
            assign \@1$vert_alive_accum = L1b_LIFE.L1_Yy_vert_alive_accum_a1[yy];

            //
            // Scope: >xx[X_SIZE-1:0]
            //
            for (xx = 0; xx <= X_SIZE-1; xx=xx+1) begin : \>xx 
               wire  \@0$Alive ;
               assign \@0$Alive = L1_LIFE.L1_Yy_Xx_Alive_a0[yy][xx];
               wire [3:0] \@1$cnt ;
               assign \@1$cnt = L1_LIFE.L2_Yy[yy].L3_Xx[xx].L3_cnt_a1;
               wire [10:0] \@1$horiz_alive_accum ;
               assign \@1$horiz_alive_accum = L1b_LIFE.L2b_Yy[yy].L2_Xx_horiz_alive_accum_a1[xx];
               wire [0:0] \@1$init_alive ;
               assign \@1$init_alive = L1_LIFE.L2_Yy[yy].L3_Xx[xx].L3_init_alive_a1;
               wire  \@0$reset ;
               assign \@0$reset = L1_LIFE.L2_Yy[yy].L3_Xx[xx].L3_reset_a0;
               wire [10:0] \@1$right_alive_accum ;
               assign \@1$right_alive_accum = LIFE_Yy_Xx_right_alive_accum_a1[yy][xx];
               wire [1:0] \@1$row_cnt ;
               assign \@1$row_cnt = L1_LIFE.L1_Yy_Xx_row_cnt_a1[yy][xx];
            end
         end
      end


   end

endgenerate


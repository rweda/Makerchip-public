// Generated by SandPiper(TM).
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


genvar entry, slave;


//
// Signals declared top-level.
//

// For |bus$hreset_n.
logic BUS_hreset_n_a0;

// For |bus>decoder$sel.
logic [1:0] BUS_Decoder_sel_a0,
            BUS_Decoder_sel_a1;

// For |bus>master>return_transfer$hrdata.
logic [31:0] BUS_Master_ReturnTransfer_hrdata_a1;

// For |bus>master>return_transfer$hreadyout.
logic BUS_Master_ReturnTransfer_hreadyout_a1;

// For |bus>master>return_transfer$hresp.
logic BUS_Master_ReturnTransfer_hresp_a1;

// For |bus>master>return_transfer$valid.
logic BUS_Master_ReturnTransfer_valid_a1;

// For |bus>master>transfer$haddr.
logic [31:0] BUS_Master_Transfer_haddr_a0;

// For |bus>master>transfer$hburst.
logic [2:0] BUS_Master_Transfer_hburst_a0;

// For |bus>master>transfer$hmastlock.
logic BUS_Master_Transfer_hmastlock_a0;

// For |bus>master>transfer$hprot.
logic [6:0] BUS_Master_Transfer_hprot_a0;

// For |bus>master>transfer$hsize.
logic [2:0] BUS_Master_Transfer_hsize_a0;

// For |bus>master>transfer$htrans.
logic [1:0] BUS_Master_Transfer_htrans_a0,
            BUS_Master_Transfer_htrans_a1;

// For |bus>master>transfer$hwdata.
logic [31:0] BUS_Master_Transfer_hwdata_a0;

// For |bus>master>transfer$hwrite.
logic [0:0] BUS_Master_Transfer_hwrite_a0;

// For |bus>mux$hrdata.
logic [31:0] BUS_Mux_hrdata_a1;

// For |bus>mux$hreadyout.
logic BUS_Mux_hreadyout_a1;

// For |bus>mux$hresp.
logic BUS_Mux_hresp_a1;

// For |bus>mux$valid.
logic BUS_Mux_valid_a1;

// For |bus>slave>transfer$haddr.
logic [7:2] BUS_Slave_Transfer_haddr_a0 [2:0],
            BUS_Slave_Transfer_haddr_a1 [2:0];

// For |bus>slave>transfer$hrdata.
logic [31:0] BUS_Slave_Transfer_hrdata_a1 [2:0];

// For |bus>slave>transfer$hreadyout.
logic BUS_Slave_Transfer_hreadyout_a1 [2:0];

// For |bus>slave>transfer$hresp.
logic BUS_Slave_Transfer_hresp_a1 [2:0];

// For |bus>slave>transfer$hwdata.
logic [31:0] BUS_Slave_Transfer_hwdata_a0 [2:0],
             BUS_Slave_Transfer_hwdata_a1 [2:0];

// For |bus>slave>transfer$hwrite.
logic [0:0] BUS_Slave_Transfer_hwrite_a0 [2:0];

// For |default$Cnt.
logic [15:0] DEFAULT_Cnt_n1,
             DEFAULT_Cnt_a0;


//
// Scope: |bus
//

//
// Scope: |bus>slave[2:0]
//

//
// Scope: |bus>slave>entry[63:0]
//

// Clock signals.
logic clkF_BUS_Slave_Entry_write_a2 [2:0][63:0];



   //
   // Scope: |bus
   //


      //
      // Scope: >decoder
      //

         // Staging of $sel.
         always_ff @(posedge clk) BUS_Decoder_sel_a1[1:0] <= BUS_Decoder_sel_a0[1:0];



      //
      // Scope: >master
      //


         //
         // Scope: >transfer
         //

            // Staging of $htrans.
            always_ff @(posedge clk) BUS_Master_Transfer_htrans_a1[1:0] <= BUS_Master_Transfer_htrans_a0[1:0];




      //
      // Scope: >slave[2:0]
      //
      generate for (slave = 0; slave <= 2; slave++) begin : L1gen_BUS_Slave
         // Staging of $entry_index.
         always_ff @(posedge clk) L1_BUS_Slave[slave].L1_entry_index_a1[5:0] <= L1_BUS_Slave[slave].L1_entry_index_a0[5:0];

         // Staging of $read.
         always_ff @(posedge clk) L1_BUS_Slave[slave].L1_read_a1 <= L1_BUS_Slave[slave].L1_read_a0;

         // Staging of $write.
         always_ff @(posedge clk) L1_BUS_Slave[slave].L1_write_a1 <= L1_BUS_Slave[slave].L1_write_a0;


         //
         // Scope: >entry[63:0]
         //
         for (entry = 0; entry <= 63; entry++) begin : L2gen_Entry
            // Update state with next state or hold.
            assign L1_BUS_Slave[slave].L1_Entry_Data_a0[entry] = !L1_BUS_Slave[slave].L2_Entry[entry].L2_write_a1 ? L1_BUS_Slave[slave].L1_Entry_Data_a1[entry][31:0] : L1_BUS_Slave[slave].w_L1_Entry_Data_a0[entry];
            // Staging of $Data.
            always_ff @(posedge clkF_BUS_Slave_Entry_write_a2[slave][entry]) L1_BUS_Slave[slave].L1_Entry_Data_a1[entry][31:0] <= L1_BUS_Slave[slave].L1_Entry_Data_a0[entry][31:0];

         end

         //
         // Scope: >transfer
         //

            // Staging of $haddr.
            always_ff @(posedge clk) BUS_Slave_Transfer_haddr_a1[slave][7:2] <= BUS_Slave_Transfer_haddr_a0[slave][7:2];

            // Staging of $hwdata.
            always_ff @(posedge clk) BUS_Slave_Transfer_hwdata_a1[slave][31:0] <= BUS_Slave_Transfer_hwdata_a0[slave][31:0];


      end endgenerate


   //
   // Scope: |default
   //

      // Staging of $Cnt.
      always_ff @(posedge clk) DEFAULT_Cnt_a0[15:0] <= DEFAULT_Cnt_n1[15:0];





//
// Gated clocks.
//



   //
   // Scope: |bus
   //


      //
      // Scope: >slave[2:0]
      //
      generate for (slave = 0; slave <= 2; slave++) begin : L1clk_BUS_Slave

         //
         // Scope: >entry[63:0]
         //
         for (entry = 0; entry <= 63; entry++) begin : L2clk_Entry
            clk_gate gen_clkF_BUS_Slave_Entry_write_a2(clkF_BUS_Slave_Entry_write_a2[slave][entry], clk, L1_BUS_Slave[slave].L2_Entry[entry].L2_write_a1, 1'b1, 1'b0);
         end
      end endgenerate





//
// Debug Signals
//

generate

   if (1) begin : DEBUG_SIGS


      //
      // Scope: |bus
      //
      if (1) begin : \|bus 
         logic  \@0$hreset_n ;
         assign \@0$hreset_n = BUS_hreset_n_a0;

         //
         // Scope: >decoder
         //
         if (1) begin : \>decoder 
            logic [1:0] \@0$sel ;
            assign \@0$sel = BUS_Decoder_sel_a0;

            //
            // Scope: >slave[2:0]
            //
            for (slave = 0; slave <= 2; slave++) begin : \>slave 
               logic  \@0$hsel ;
               assign \@0$hsel = L1_BUS_Decoder_Slave[slave].L1_hsel_a0;
            end
         end

         //
         // Scope: >master
         //
         if (1) begin : \>master 

            //
            // Scope: >return_transfer
            //
            if (1) begin : \>return_transfer 
               logic [31:0] \@1$hrdata ;
               assign \@1$hrdata = BUS_Master_ReturnTransfer_hrdata_a1;
               logic  \@1$hreadyout ;
               assign \@1$hreadyout = BUS_Master_ReturnTransfer_hreadyout_a1;
               logic  \@1$hresp ;
               assign \@1$hresp = BUS_Master_ReturnTransfer_hresp_a1;
               logic  \@1$valid ;
               assign \@1$valid = BUS_Master_ReturnTransfer_valid_a1;
            end

            //
            // Scope: >transfer
            //
            if (1) begin : \>transfer 
               logic [31:0] \@0$haddr ;
               assign \@0$haddr = BUS_Master_Transfer_haddr_a0;
               logic [2:0] \@0$hburst ;
               assign \@0$hburst = BUS_Master_Transfer_hburst_a0;
               logic  \@0$hmastlock ;
               assign \@0$hmastlock = BUS_Master_Transfer_hmastlock_a0;
               logic [6:0] \@0$hprot ;
               assign \@0$hprot = BUS_Master_Transfer_hprot_a0;
               logic [2:0] \@0$hsize ;
               assign \@0$hsize = BUS_Master_Transfer_hsize_a0;
               logic [1:0] \@0$htrans ;
               assign \@0$htrans = BUS_Master_Transfer_htrans_a0;
               logic [31:0] \@0$hwdata ;
               assign \@0$hwdata = BUS_Master_Transfer_hwdata_a0;
               logic [0:0] \@0$hwrite ;
               assign \@0$hwrite = BUS_Master_Transfer_hwrite_a0;
            end
         end

         //
         // Scope: >mux
         //
         if (1) begin : \>mux 
            logic [31:0] \@1$hrdata ;
            assign \@1$hrdata = BUS_Mux_hrdata_a1;
            logic  \@1$hreadyout ;
            assign \@1$hreadyout = BUS_Mux_hreadyout_a1;
            logic  \@1$hresp ;
            assign \@1$hresp = BUS_Mux_hresp_a1;
            logic  \@1$valid ;
            assign \@1$valid = BUS_Mux_valid_a1;
         end

         //
         // Scope: >slave[2:0]
         //
         for (slave = 0; slave <= 2; slave++) begin : \>slave 
            logic [5:0] \@0$entry_index ;
            assign \@0$entry_index = L1_BUS_Slave[slave].L1_entry_index_a0;
            logic  \@0$read ;
            assign \@0$read = L1_BUS_Slave[slave].L1_read_a0;
            logic  \@0$write ;
            assign \@0$write = L1_BUS_Slave[slave].L1_write_a0;

            //
            // Scope: >entry[63:0]
            //
            for (entry = 0; entry <= 63; entry++) begin : \>entry 
               logic [31:0] \@0$Data ;
               assign \@0$Data = L1_BUS_Slave[slave].L1_Entry_Data_a0[entry];
               logic  \@1$write ;
               assign \@1$write = L1_BUS_Slave[slave].L2_Entry[entry].L2_write_a1;
            end

            //
            // Scope: >transfer
            //
            if (1) begin : \>transfer 
               logic [7:2] \@0$haddr ;
               assign \@0$haddr = BUS_Slave_Transfer_haddr_a0[slave];
               logic [31:0] \@1$hrdata ;
               assign \@1$hrdata = BUS_Slave_Transfer_hrdata_a1[slave];
               logic  \@1$hreadyout ;
               assign \@1$hreadyout = BUS_Slave_Transfer_hreadyout_a1[slave];
               logic  \@1$hresp ;
               assign \@1$hresp = BUS_Slave_Transfer_hresp_a1[slave];
               logic [31:0] \@0$hwdata ;
               assign \@0$hwdata = BUS_Slave_Transfer_hwdata_a0[slave];
               logic [0:0] \@0$hwrite ;
               assign \@0$hwrite = BUS_Slave_Transfer_hwrite_a0[slave];
            end
         end
      end

      //
      // Scope: |default
      //
      if (1) begin : \|default 
         logic [15:0] \@-1$Cnt ;
         assign \@-1$Cnt = DEFAULT_Cnt_n1;
      end


   end

endgenerate


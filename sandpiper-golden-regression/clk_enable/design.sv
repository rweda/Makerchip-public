//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM)

module clk_gating(input logic clk, input logic reset, input logic [15:0] cyc_cnt, output logic passed, output logic failed); 
   logic [7:0] nine;
`include "design_gen.sv" //_\TLV
   // Pipesignal and state assignment under when earlier condition.
   //_|pipe
      //_@0
         assign PIPE_reset_a0 = reset;
         assign PIPE_valid_a0 = PIPE_reset_a0 ? 1'b1 : ! PIPE_valid_a1;  // Assert every other cycle.
         assign PIPE_valid2_a0 = PIPE_reset_a0 ? 1'b1 : PIPE_reset_a1 ? 1'b0 : PIPE_valid2_a3;  // Deassert every 3rd cycle.
   //_|pipe
      //_?$valid
         //_@0
            assign PIPE_cnt_a0[7:0] = cyc_cnt[7:0];
         //_@2
            assign PIPE_State_a1[7:0] = !PIPE_valid_a2 ? PIPE_State_a2[7:0] : PIPE_cnt_a2;
         //_@4
            assign PIPE_bar_a4[7:0] = PIPE_cnt_a4;
            // Pipesignal and state assignment under same-stage nested when condition.
            for (hier = 0; hier <= 1; hier++) begin : L1_PIPE_Hier //_/hier
               assign PIPE_Hier_valid2_a4[hier] = PIPE_valid2_a4;
               //_?$valid2
                  assign PIPE_Hier_foo_a4[hier][7:0] = PIPE_bar_a4;
                  assign PIPE_Hier_Foo_a3[hier][7:0] = !PIPE_Hier_g0_valid2_a4[hier] ? PIPE_Hier_Foo_a4[hier][7:0] : PIPE_bar_a4;
                  assign PIPE_Hier_Cnt_a3[hier][7:0] = !PIPE_Hier_g0_valid2_a4[hier] ? PIPE_Hier_Cnt_a4[hier][7:0] : PIPE_reset_a4 ? 8'b0 : PIPE_Hier_Cnt_a4[hier] + 1'b1;
                  /*SV_plus*/
                     always_ff @(posedge clk) begin
                        if (PIPE_valid_a4 && PIPE_Hier_valid2_a4[hier] && ! PIPE_reset_a4 && ! PIPE_reset_a0) begin
                           $display("hier[%h], cyc: %h, Cnt: %h", hier, cyc_cnt, PIPE_Hier_Cnt_a3[hier]);
                        end
                     end
            end
            `BOGUS_USE(PIPE_State_a4)
      
   //_|pipe2
      //_@0
         assign PIPE2_odd_a0 = reset ? 0 : ! PIPE2_odd_a1;
         assign PIPE2_bob_a0 = PIPE2_odd_a1;
      //_?$odd
         //_@0
            assign PIPE2_State_n1 = !PIPE2_odd_a0 ? PIPE2_State_a0 : reset ? 0 : PIPE2_odd_a0;
            `BOGUS_USE(PIPE2_State_n1)
         // Conditioned $ANY.
         //_/copy
            //_@0
               assign {PIPE2_Copy_bob_a0} = {PIPE2_bob_a0};
            //_@0
               `BOGUS_USE(PIPE2_Copy_bob_a0)
            // Block and multiple state assignments.
            //_@3
               always_comb begin
                  w_PIPE2_Copy_One_a2[7:0] = 8'd1;
                  w_PIPE2_Copy_Two_a2[7:0] = 8'd2;
               end
               /*SV_plus*/
                  assign w_PIPE2_Copy_Three_a2[7:0] = 8'd3;
                  assign w_PIPE2_Copy_Four_a2[7:0] = 8'd4;
               assign {w_PIPE2_Copy_Five_a2[7:0], w_PIPE2_Copy_Six_a2[7:0]} = {8'd5, 8'd6};
               assign {w_PIPE2_Copy_Seven_a2[7:0], PIPE2_Copy_eight_a3[7:0], nine} = {8'd7, 8'd8, 8'd9};
               `BOGUS_USE(PIPE2_Copy_One_a3 PIPE2_Copy_Two_a3 PIPE2_Copy_Three_a3 PIPE2_Copy_Four_a3 PIPE2_Copy_Five_a3 PIPE2_Copy_Six_a3 PIPE2_Copy_Seven_a3 PIPE2_Copy_eight_a3)
               
               
                  
   // Detect failure.
   //_|pipe
      //_@4
         for (hier = 0; hier <= 1; hier++) begin : L1b_PIPE_Hier //_/hier
            assign PIPE_Hier_bad_a4[hier] = (PIPE_Hier_foo_a4[hier] != PIPE_Hier_Foo_a3[hier]) && (PIPE_valid_a4 && PIPE_valid2_a4);
            assign PIPE_Hier_final_cnt_a4[hier] = PIPE_Hier_Cnt_a4[hier] == 8'd12;
            assign PIPE_Hier_failed_a4[hier] = ! reset && ! PIPE_reset_a4 && (PIPE_Hier_bad_a4[hier] || (cyc_cnt == 39 && ! PIPE_Hier_final_cnt_a4[hier]));
         end
      
         // Fail if either /hier[*] failed.
         assign passed = cyc_cnt > 40;
         assign failed = | PIPE_Hier_failed_a4;
         

//_\SV
endmodule


// Undefine macros defined by SandPiper (in "design_gen.sv").
`undef BOGUS_USE

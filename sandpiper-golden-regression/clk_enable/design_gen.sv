// Generated by SandPiper(TM).
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


genvar hier;


//
// Scope: |pipe
//

// For |pipe$State.
logic [7:0] PIPE_State_a1;
logic [7:0] PIPE_State_a2;
logic [7:0] PIPE_State_a3;
logic [7:0] PIPE_State_a4;

// For |pipe$bar.
logic [7:0] PIPE_bar_a4;

// For |pipe$cnt.
logic [7:0] PIPE_cnt_a0;
logic [7:0] PIPE_cnt_a1;
logic [7:0] PIPE_cnt_a2;
logic [7:0] PIPE_cnt_a3;
logic [7:0] PIPE_cnt_a4;

// For |pipe$reset.
logic PIPE_reset_a0;
logic PIPE_reset_a1;
logic PIPE_reset_a2;
logic PIPE_reset_a3;
logic PIPE_reset_a4;

// For |pipe$valid.
logic PIPE_valid_a0;
logic PIPE_valid_a1;
logic PIPE_valid_a2;
logic PIPE_valid_a3;
logic PIPE_valid_a4;

// For |pipe$valid2.
logic PIPE_valid2_a0;
logic PIPE_valid2_a1;
logic PIPE_valid2_a2;
logic PIPE_valid2_a3;
logic PIPE_valid2_a4;

//
// Scope: |pipe/hier[1:0]
//

// For |pipe/hier$Cnt.
logic [7:0] PIPE_Hier_Cnt_a3 [1:0];
logic [7:0] PIPE_Hier_Cnt_a4 [1:0];

// For |pipe/hier$Foo.
logic [7:0] PIPE_Hier_Foo_a3 [1:0];
logic [7:0] PIPE_Hier_Foo_a4 [1:0];

// For |pipe/hier$bad.
logic PIPE_Hier_bad_a4 [1:0];

// For |pipe/hier$failed.
logic [1:0] PIPE_Hier_failed_a4;

// For |pipe/hier$final_cnt.
logic PIPE_Hier_final_cnt_a4 [1:0];

// For |pipe/hier$foo.
logic [7:0] PIPE_Hier_foo_a4 [1:0];

// For |pipe/hier$g0_valid2.
logic PIPE_Hier_g0_valid2_a4 [1:0];

// For |pipe/hier$valid2.
logic PIPE_Hier_valid2_a4 [1:0];

//
// Scope: |pipe2
//

// For |pipe2$State.
logic PIPE2_State_n1;
logic PIPE2_State_a0;

// For |pipe2$bob.
logic PIPE2_bob_a0;

// For |pipe2$odd.
logic PIPE2_odd_a0;
logic PIPE2_odd_a1;
logic PIPE2_odd_a2;
logic PIPE2_odd_a3;

//
// Scope: |pipe2/copy
//

// For |pipe2/copy$Five.
logic [7:0] w_PIPE2_Copy_Five_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Five_a2;
logic [7:0] PIPE2_Copy_Five_a3;

// For |pipe2/copy$Four.
logic [7:0] w_PIPE2_Copy_Four_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Four_a2;
logic [7:0] PIPE2_Copy_Four_a3;

// For |pipe2/copy$One.
logic [7:0] w_PIPE2_Copy_One_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_One_a2;
logic [7:0] PIPE2_Copy_One_a3;

// For |pipe2/copy$Seven.
logic [7:0] w_PIPE2_Copy_Seven_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Seven_a2;
logic [7:0] PIPE2_Copy_Seven_a3;

// For |pipe2/copy$Six.
logic [7:0] w_PIPE2_Copy_Six_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Six_a2;
logic [7:0] PIPE2_Copy_Six_a3;

// For |pipe2/copy$Three.
logic [7:0] w_PIPE2_Copy_Three_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Three_a2;
logic [7:0] PIPE2_Copy_Three_a3;

// For |pipe2/copy$Two.
logic [7:0] w_PIPE2_Copy_Two_a2 /* without recirculation for "when" condition */;
logic [7:0] PIPE2_Copy_Two_a2;
logic [7:0] PIPE2_Copy_Two_a3;

// For |pipe2/copy$bob.
logic PIPE2_Copy_bob_a0;

// For |pipe2/copy$eight.
logic [7:0] PIPE2_Copy_eight_a3;



   //
   // Scope: |pipe
   //

      // Staging of $State.
      always_ff @(posedge clk) if ((PIPE_valid_a2 ? 1'b1 : 1'bx)) PIPE_State_a2[7:0] <= PIPE_State_a1[7:0];
      always_ff @(posedge clk) if ((PIPE_valid_a3 ? 1'b1 : 1'bx)) PIPE_State_a3[7:0] <= PIPE_State_a2[7:0];
      always_ff @(posedge clk) if ((PIPE_valid_a4 ? 1'b1 : 1'bx)) PIPE_State_a4[7:0] <= PIPE_State_a3[7:0];

      // Staging of $cnt.
      always_ff @(posedge clk) if ((PIPE_valid_a0 ? 1'b1 : 1'bx)) PIPE_cnt_a1[7:0] <= PIPE_cnt_a0[7:0];
      always_ff @(posedge clk) if ((PIPE_valid_a1 ? 1'b1 : 1'bx)) PIPE_cnt_a2[7:0] <= PIPE_cnt_a1[7:0];
      always_ff @(posedge clk) if ((PIPE_valid_a2 ? 1'b1 : 1'bx)) PIPE_cnt_a3[7:0] <= PIPE_cnt_a2[7:0];
      always_ff @(posedge clk) if ((PIPE_valid_a3 ? 1'b1 : 1'bx)) PIPE_cnt_a4[7:0] <= PIPE_cnt_a3[7:0];

      // Staging of $reset.
      always_ff @(posedge clk) PIPE_reset_a1 <= PIPE_reset_a0;
      always_ff @(posedge clk) PIPE_reset_a2 <= PIPE_reset_a1;
      always_ff @(posedge clk) PIPE_reset_a3 <= PIPE_reset_a2;
      always_ff @(posedge clk) PIPE_reset_a4 <= PIPE_reset_a3;

      // Staging of $valid.
      always_ff @(posedge clk) PIPE_valid_a1 <= PIPE_valid_a0;
      always_ff @(posedge clk) PIPE_valid_a2 <= PIPE_valid_a1;
      always_ff @(posedge clk) PIPE_valid_a3 <= PIPE_valid_a2;
      always_ff @(posedge clk) PIPE_valid_a4 <= PIPE_valid_a3;

      // Staging of $valid2.
      always_ff @(posedge clk) PIPE_valid2_a1 <= PIPE_valid2_a0;
      always_ff @(posedge clk) PIPE_valid2_a2 <= PIPE_valid2_a1;
      always_ff @(posedge clk) PIPE_valid2_a3 <= PIPE_valid2_a2;
      always_ff @(posedge clk) PIPE_valid2_a4 <= PIPE_valid2_a3;


      //
      // Scope: /hier[1:0]
      //
      for (hier = 0; hier <= 1; hier++) begin : L1gen_PIPE_Hier
         // Staging of $Cnt.
         always_ff @(posedge clk) if ((PIPE_Hier_g0_valid2_a4[hier] ? 1'b1 : 1'bx)) PIPE_Hier_Cnt_a4[hier][7:0] <= PIPE_Hier_Cnt_a3[hier][7:0];

         // Staging of $Foo.
         always_ff @(posedge clk) if ((PIPE_Hier_g0_valid2_a4[hier] ? 1'b1 : 1'bx)) PIPE_Hier_Foo_a4[hier][7:0] <= PIPE_Hier_Foo_a3[hier][7:0];

         // Staging of an unconditioned version of a condition signal.
         assign PIPE_Hier_g0_valid2_a4[hier] = PIPE_Hier_valid2_a4[hier] && PIPE_valid_a4;

      end


   //
   // Scope: |pipe2
   //

      // Staging of $State.
      always_ff @(posedge clk) if ((PIPE2_odd_a0 ? 1'b1 : 1'bx)) PIPE2_State_a0 <= PIPE2_State_n1;

      // Staging of $odd.
      always_ff @(posedge clk) PIPE2_odd_a1 <= PIPE2_odd_a0;
      always_ff @(posedge clk) PIPE2_odd_a2 <= PIPE2_odd_a1;
      always_ff @(posedge clk) PIPE2_odd_a3 <= PIPE2_odd_a2;


      //
      // Scope: /copy
      //

         // Update state with next state or hold.
         assign PIPE2_Copy_Five_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Five_a3[7:0] : w_PIPE2_Copy_Five_a2;
         // Staging of $Five.
         always_ff @(posedge clk) if ((PIPE2_odd_a3 ? 1'b1 : 1'bx)) PIPE2_Copy_Five_a3[7:0] <= PIPE2_Copy_Five_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Four_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Four_a3[7:0] : w_PIPE2_Copy_Four_a2;
         // Staging of $Four.
         always_ff @(posedge clk) if ((PIPE2_odd_a3 ? 1'b1 : 1'bx)) PIPE2_Copy_Four_a3[7:0] <= PIPE2_Copy_Four_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_One_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_One_a3[7:0] : w_PIPE2_Copy_One_a2;
         // Staging of $One.
         always_ff @(posedge clk) if ((PIPE2_odd_a3 ? 1'b1 : 1'bx)) PIPE2_Copy_One_a3[7:0] <= PIPE2_Copy_One_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Seven_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Seven_a3[7:0] : w_PIPE2_Copy_Seven_a2;
         // Staging of $Seven.
         always_ff @(posedge clk) if ((PIPE2_odd_a3 ? 1'b1 : 1'bx)) PIPE2_Copy_Seven_a3[7:0] <= PIPE2_Copy_Seven_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Six_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Six_a3[7:0] : w_PIPE2_Copy_Six_a2;
         // Staging of $Six.
         always_ff @(posedge clk) if ((PIPE2_odd_a3 ? 1'b1 : 1'bx)) PIPE2_Copy_Six_a3[7:0] <= PIPE2_Copy_Six_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Three_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Three_a3[7:0] : w_PIPE2_Copy_Three_a2;
         // Staging of $Three.
         always_ff @(posedge clk) if ((PIPE2_odd_a3 ? 1'b1 : 1'bx)) PIPE2_Copy_Three_a3[7:0] <= PIPE2_Copy_Three_a2[7:0];

         // Update state with next state or hold.
         assign PIPE2_Copy_Two_a2 = !PIPE2_odd_a3 ? PIPE2_Copy_Two_a3[7:0] : w_PIPE2_Copy_Two_a2;
         // Staging of $Two.
         always_ff @(posedge clk) if ((PIPE2_odd_a3 ? 1'b1 : 1'bx)) PIPE2_Copy_Two_a3[7:0] <= PIPE2_Copy_Two_a2[7:0];







//
// Debug Signals
//

   if (1) begin : DEBUG_SIGS


      //
      // Scope: |pipe
      //
      if (1) begin : \|pipe 
         logic [7:0] \@1$State ;
         assign \@1$State = PIPE_State_a1;
         logic [7:0] \@4$bar ;
         assign \@4$bar = PIPE_bar_a4;
         logic [7:0] \@0$cnt ;
         assign \@0$cnt = PIPE_cnt_a0;
         logic  \@0$reset ;
         assign \@0$reset = PIPE_reset_a0;
         logic  \@0$valid ;
         assign \@0$valid = PIPE_valid_a0;
         logic  \@0$valid2 ;
         assign \@0$valid2 = PIPE_valid2_a0;

         //
         // Scope: /hier[1:0]
         //
         for (hier = 0; hier <= 1; hier++) begin : \/hier 
            logic [7:0] \@3$Cnt ;
            assign \@3$Cnt = PIPE_Hier_Cnt_a3[hier];
            logic [7:0] \@3$Foo ;
            assign \@3$Foo = PIPE_Hier_Foo_a3[hier];
            logic  \@4$bad ;
            assign \@4$bad = PIPE_Hier_bad_a4[hier];
            logic  \@4$failed ;
            assign \@4$failed = PIPE_Hier_failed_a4[hier];
            logic  \@4$final_cnt ;
            assign \@4$final_cnt = PIPE_Hier_final_cnt_a4[hier];
            logic [7:0] \@4$foo ;
            assign \@4$foo = PIPE_Hier_foo_a4[hier];
            logic  \@4$valid2 ;
            assign \@4$valid2 = PIPE_Hier_valid2_a4[hier];
         end
      end

      //
      // Scope: |pipe2
      //
      if (1) begin : \|pipe2 
         logic  \@-1$State ;
         assign \@-1$State = PIPE2_State_n1;
         logic  \@0$bob ;
         assign \@0$bob = PIPE2_bob_a0;
         logic  \@0$odd ;
         assign \@0$odd = PIPE2_odd_a0;

         //
         // Scope: /copy
         //
         if (1) begin : \/copy 
            logic  \@0$ANY ;
            assign \@0$ANY  = 1'b1;
            logic [7:0] \@2$Five ;
            assign \@2$Five = PIPE2_Copy_Five_a2;
            logic [7:0] \@2$Four ;
            assign \@2$Four = PIPE2_Copy_Four_a2;
            logic [7:0] \@2$One ;
            assign \@2$One = PIPE2_Copy_One_a2;
            logic [7:0] \@2$Seven ;
            assign \@2$Seven = PIPE2_Copy_Seven_a2;
            logic [7:0] \@2$Six ;
            assign \@2$Six = PIPE2_Copy_Six_a2;
            logic [7:0] \@2$Three ;
            assign \@2$Three = PIPE2_Copy_Three_a2;
            logic [7:0] \@2$Two ;
            assign \@2$Two = PIPE2_Copy_Two_a2;
            logic  \@0$bob ;
            assign \@0$bob = PIPE2_Copy_bob_a0;
            logic [7:0] \@3$eight ;
            assign \@3$eight = PIPE2_Copy_eight_a3;
         end
      end


   end


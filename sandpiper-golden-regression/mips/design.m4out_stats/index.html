<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
   <meta http-equiv="description" content="index.html">
   <meta http-equiv="keywords" content="tl-verilog">

   <title>design.m4out.tlv -> design.sv & design_gen.sv</title>

   <link rel="stylesheet" href="tlx.css" />
<!--Load styles for stats page-->
<link rel="stylesheet" href="http://www.rweda.com/lib/sp_1.14-2022_10_10-beta-Pro/stats.css" />
<!--Load the AJAX API-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="http://www.rweda.com/lib/sp_1.14-2022_10_10-beta-Pro/stats.js"></script>
<script type="text/javascript">

  function getTitle() {
    return "design.m4out.tlv -> design.sv & design_gen.sv";
  }

  function chartData() {
    return [
      ['File(s)', 'Unknown', 'Untouched', 'Logic', 'Declarations', 'Staging', 'Structure', 'Validity', '(Instrumentation)', { role: 'style' }, '(Comments)', { role: 'style' }, '(Whitespace)', { role: 'style' }],
      ['design.m4out.tlv', 0, 9380, 3082, 0, 38, 63, 66, 0, 'opacity: 0.1', 4025, 'opacity: 0.1', 10088, 'opacity: 0.1'],
      ['design.sv', 0, 9380, 7148, 0, 0, 48, 0, 0, 'opacity: 0.1', 4369, 'opacity: 0.1', 10152, 'opacity: 0.1'],
      ['design_gen.sv', 0, 0, 0, 4652, 5040, 154, 2318, 0, 'opacity: 0.1', 3872, 'opacity: 0.1', 2270, 'opacity: 0.1'],
      ['SV Total', 0, 9380, 7148, 4652, 5040, 202, 2318, 0, 'opacity: 0.1', 8241, 'opacity: 0.1', 12422, 'opacity: 0.1']
    ];
  }

  function chartColors() {
    return ['#505050', '#305050', 'purple', 'blue', '#509050', '#1090c0', '#E04010', '#a07090', '#707070', '#7090a0'];
  };
</script>
</head>

<body>

    <div id="four_square">
        <div id="chart_div" class="cell left top"></div>
        <div id="gen_div" class="cell code right top">

<pre>
<span class="tlx_comments">// Generated by SandPiper(TM).
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
</span><span class="tlx_structure">`define BOGUS_USE(ignore)


</span><span class="tlx_comments">// For X injection on assignments, disableable using `define SP_PHYS.
</span><span class="tlx_structure">`ifdef WHEN
   $warning(&quot;WHEN macro redefined.&quot;);
`endif
`ifdef SP_PHYS
   `define WHEN(valid_sig)
`else
   `define WHEN(valid_sig) !valid_sig ? 'x :
`endif





</span><span class="tlx_comments">//
// Signals declared top-level.
//

// For &gt;pipelined|cpu$Pc.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Pipelined_CPU_Pc_a0;
logic [WIDTH-1:0] Pipelined_CPU_Pc_a1;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$alu_control.
</span><span class="tlx_declarations">logic [2:0] w_Pipelined_CPU_alu_control_a6 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [2:0] Pipelined_CPU_alu_control_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$alu_op.
</span><span class="tlx_declarations">logic [1:0] w_Pipelined_CPU_alu_op_a6 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [1:0] Pipelined_CPU_alu_op_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$alu_out.
</span><span class="tlx_declarations">logic [WIDTH-1:0] w_Pipelined_CPU_alu_out_a6 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [WIDTH-1:0] Pipelined_CPU_alu_out_a6;
logic [WIDTH-1:0] Pipelined_CPU_alu_out_a7;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$alu_valid.
</span><span class="tlx_declarations">logic Pipelined_CPU_alu_valid_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$beq_target_calc.
</span><span class="tlx_declarations">logic Pipelined_CPU_beq_target_calc_a6;
logic Pipelined_CPU_beq_target_calc_a7;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$beq_type.
</span><span class="tlx_declarations">logic Pipelined_CPU_beq_type_a5;
logic Pipelined_CPU_beq_type_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$beq_update_pc.
</span><span class="tlx_declarations">logic Pipelined_CPU_beq_update_pc_a7;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$fetch.
</span><span class="tlx_declarations">logic Pipelined_CPU_fetch_a1;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$funct.
</span><span class="tlx_declarations">logic [5:0] w_Pipelined_CPU_funct_a5;
logic [5:0] Pipelined_CPU_funct_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$imm.
</span><span class="tlx_declarations">logic [7:0] w_Pipelined_CPU_imm_a5;
logic [7:0] Pipelined_CPU_imm_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$imm_x4.
</span><span class="tlx_declarations">logic [7:0] w_Pipelined_CPU_imm_x4_a5 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [7:0] Pipelined_CPU_imm_x4_a5;
logic [7:0] Pipelined_CPU_imm_x4_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$instr.
</span><span class="tlx_declarations">logic [31:0] w_Pipelined_CPU_instr_a4;
logic [31:0] Pipelined_CPU_instr_a5;
logic [31:11] Pipelined_CPU_instr_a6;
logic [31:11] Pipelined_CPU_instr_a7;
logic [31:16] Pipelined_CPU_instr_a8;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$jtype.
</span><span class="tlx_declarations">logic Pipelined_CPU_jtype_a5;
logic Pipelined_CPU_jtype_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$lb_type.
</span><span class="tlx_declarations">logic Pipelined_CPU_lb_type_a5;
logic Pipelined_CPU_lb_type_a6;
logic Pipelined_CPU_lb_type_a7;
logic Pipelined_CPU_lb_type_a8;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$mem_read.
</span><span class="tlx_declarations">logic Pipelined_CPU_mem_read_a1;
logic Pipelined_CPU_mem_read_a2;
logic Pipelined_CPU_mem_read_a3;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$mem_type.
</span><span class="tlx_declarations">logic Pipelined_CPU_mem_type_a5;
logic Pipelined_CPU_mem_type_a6;
logic Pipelined_CPU_mem_type_a7;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$memdata.
</span><span class="tlx_declarations">logic [WIDTH-1:0] w_Pipelined_CPU_memdata_a1 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [WIDTH-1:0] Pipelined_CPU_memdata_a1;
logic [WIDTH-1:0] Pipelined_CPU_memdata_a2;
logic [WIDTH-1:0] Pipelined_CPU_memdata_a3;
logic [WIDTH-1:0] Pipelined_CPU_memdata_a4;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$op.
</span><span class="tlx_declarations">logic [5:0] w_Pipelined_CPU_op_a5 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [5:0] Pipelined_CPU_op_a5;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$ra1.
</span><span class="tlx_declarations">logic [REGBITS-1:0] Pipelined_CPU_ra1_a5;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$ra2.
</span><span class="tlx_declarations">logic [REGBITS-1:0] Pipelined_CPU_ra2_a5;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$rd1.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Pipelined_CPU_rd1_a5;
logic [WIDTH-1:0] Pipelined_CPU_rd1_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$rd2.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Pipelined_CPU_rd2_a5;
logic [WIDTH-1:0] Pipelined_CPU_rd2_a6;
logic [WIDTH-1:0] Pipelined_CPU_rd2_a7;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$regwrite.
</span><span class="tlx_declarations">logic Pipelined_CPU_regwrite_a5;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$reset.
</span><span class="tlx_declarations">logic Pipelined_CPU_reset_a0;
logic Pipelined_CPU_reset_a1;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$rtype.
</span><span class="tlx_declarations">logic Pipelined_CPU_rtype_a5;
logic Pipelined_CPU_rtype_a6;
logic Pipelined_CPU_rtype_a7;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$sb_type.
</span><span class="tlx_declarations">logic Pipelined_CPU_sb_type_a5;
logic Pipelined_CPU_sb_type_a6;
logic Pipelined_CPU_sb_type_a7;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$src_a.
</span><span class="tlx_declarations">logic [WIDTH-1:0] w_Pipelined_CPU_src_a_a6 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [WIDTH-1:0] Pipelined_CPU_src_a_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$src_b.
</span><span class="tlx_declarations">logic [WIDTH-1:0] w_Pipelined_CPU_src_b_a6 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [WIDTH-1:0] Pipelined_CPU_src_b_a6;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$valid_instr.
</span><span class="tlx_declarations">logic Pipelined_CPU_valid_instr_a0;
logic Pipelined_CPU_valid_instr_a1;
logic Pipelined_CPU_valid_instr_a2;
logic Pipelined_CPU_valid_instr_a3;
logic Pipelined_CPU_valid_instr_a4;
logic Pipelined_CPU_valid_instr_a5;
logic Pipelined_CPU_valid_instr_a6;
logic Pipelined_CPU_valid_instr_a7;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$wa.
</span><span class="tlx_declarations">logic [REGBITS-1:0] w_Pipelined_CPU_wa_a5 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [REGBITS-1:0] Pipelined_CPU_wa_a5;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$wd.
</span><span class="tlx_declarations">logic [WIDTH-1:0] w_Pipelined_CPU_wd_a5 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic [WIDTH-1:0] Pipelined_CPU_wd_a5;

</span><span class="tlx_comments">// For &gt;pipelined|cpu$zero.
</span><span class="tlx_declarations">logic w_Pipelined_CPU_zero_a6 </span><span class="tlx_comments">/* without X injection for &quot;when&quot; condition */</span><span class="tlx_declarations">;
logic Pipelined_CPU_zero_a6;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$Pc.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Unpipelined_CPU_Pc_a0;
logic [WIDTH-1:0] Unpipelined_CPU_Pc_a1;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$alu_control.
</span><span class="tlx_declarations">logic [2:0] Unpipelined_CPU_alu_control_a6;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$alu_op.
</span><span class="tlx_declarations">logic [1:0] Unpipelined_CPU_alu_op_a6;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$alu_out.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Unpipelined_CPU_alu_out_a6;
logic [WIDTH-1:0] Unpipelined_CPU_alu_out_a7;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$beq_target_calc.
</span><span class="tlx_declarations">logic Unpipelined_CPU_beq_target_calc_a6;
logic Unpipelined_CPU_beq_target_calc_a7;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$beq_type.
</span><span class="tlx_declarations">logic Unpipelined_CPU_beq_type_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$beq_update_pc.
</span><span class="tlx_declarations">logic Unpipelined_CPU_beq_update_pc_a7;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$fetch.
</span><span class="tlx_declarations">logic Unpipelined_CPU_fetch_a1;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$funct.
</span><span class="tlx_declarations">logic [5:0] Unpipelined_CPU_funct_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$imm.
</span><span class="tlx_declarations">logic [7:0] Unpipelined_CPU_imm_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$imm_x4.
</span><span class="tlx_declarations">logic [7:0] Unpipelined_CPU_imm_x4_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$instr.
</span><span class="tlx_declarations">logic [31:0] Unpipelined_CPU_instr_a4;
logic [31:0] Unpipelined_CPU_instr_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$jtype.
</span><span class="tlx_declarations">logic Unpipelined_CPU_jtype_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$lb_type.
</span><span class="tlx_declarations">logic Unpipelined_CPU_lb_type_a5;
logic Unpipelined_CPU_lb_type_a6;
logic Unpipelined_CPU_lb_type_a7;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$mem_type.
</span><span class="tlx_declarations">logic Unpipelined_CPU_mem_type_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$memdata.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Unpipelined_CPU_memdata_a1;
logic [WIDTH-1:0] Unpipelined_CPU_memdata_a2;
logic [WIDTH-1:0] Unpipelined_CPU_memdata_a3;
logic [WIDTH-1:0] Unpipelined_CPU_memdata_a4;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$op.
</span><span class="tlx_declarations">logic [5:0] Unpipelined_CPU_op_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$ra1.
</span><span class="tlx_declarations">logic [REGBITS-1:0] Unpipelined_CPU_ra1_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$ra2.
</span><span class="tlx_declarations">logic [REGBITS-1:0] Unpipelined_CPU_ra2_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$rd1.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Unpipelined_CPU_rd1_a5;
logic [WIDTH-1:0] Unpipelined_CPU_rd1_a6;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$rd2.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Unpipelined_CPU_rd2_a5;
logic [WIDTH-1:0] Unpipelined_CPU_rd2_a6;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$regwrite.
</span><span class="tlx_declarations">logic Unpipelined_CPU_regwrite_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$reset.
</span><span class="tlx_declarations">logic Unpipelined_CPU_reset_a0;
logic Unpipelined_CPU_reset_a1;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$rtype.
</span><span class="tlx_declarations">logic Unpipelined_CPU_rtype_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$sb_type.
</span><span class="tlx_declarations">logic Unpipelined_CPU_sb_type_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$src_a.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Unpipelined_CPU_src_a_a6;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$src_b.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Unpipelined_CPU_src_b_a6;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$valid_instr.
</span><span class="tlx_declarations">logic Unpipelined_CPU_valid_instr_a0;
logic Unpipelined_CPU_valid_instr_a1;
logic Unpipelined_CPU_valid_instr_a2;
logic Unpipelined_CPU_valid_instr_a3;
logic Unpipelined_CPU_valid_instr_a4;
logic Unpipelined_CPU_valid_instr_a5;
logic Unpipelined_CPU_valid_instr_a6;
logic Unpipelined_CPU_valid_instr_a7;
logic Unpipelined_CPU_valid_instr_a8;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$wa.
</span><span class="tlx_declarations">logic [REGBITS-1:0] Unpipelined_CPU_wa_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$wd.
</span><span class="tlx_declarations">logic [WIDTH-1:0] Unpipelined_CPU_wd_a5;

</span><span class="tlx_comments">// For &gt;unpipelined|cpu$zero.
</span><span class="tlx_declarations">logic Unpipelined_CPU_zero_a6;

</span><span class="tlx_comments">
//
// Scope: &gt;pipelined
//

//
// Scope: &gt;pipelined|cpu
//

// Clock signals.
</span><span class="tlx_validity">logic clkP_Pipelined_CPU_alu_valid_a7 ;
logic clkP_Pipelined_CPU_mem_read_a2 ;
logic clkP_Pipelined_CPU_mem_read_a3 ;
logic clkP_Pipelined_CPU_mem_read_a4 ;
logic clkP_Pipelined_CPU_valid_instr_a5 ;
logic clkP_Pipelined_CPU_valid_instr_a6 ;
logic clkP_Pipelined_CPU_valid_instr_a7 ;
logic clkP_Pipelined_CPU_valid_instr_a8 ;

</span><span class="tlx_comments">

   //
   // Scope: &gt;pipelined
   //


      //
      // Scope: |cpu
      //

         // Staging of $Pc.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_Pc_a1[WIDTH-1:0] &lt;= Pipelined_CPU_Pc_a0[WIDTH-1:0];

         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_alu_control_a6 = `WHEN(Pipelined_CPU_alu_valid_a6) w_Pipelined_CPU_alu_control_a6;
         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_alu_op_a6 = `WHEN(Pipelined_CPU_alu_valid_a6) w_Pipelined_CPU_alu_op_a6;
         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_alu_out_a6 = `WHEN(Pipelined_CPU_alu_valid_a6) w_Pipelined_CPU_alu_out_a6;
         </span><span class="tlx_comments">// Staging of $alu_out.
         </span><span class="tlx_staging">always_ff @(posedge clkP_Pipelined_CPU_alu_valid_a7) Pipelined_CPU_alu_out_a7[WIDTH-1:0] &lt;= Pipelined_CPU_alu_out_a6[WIDTH-1:0];

         </span><span class="tlx_comments">// Staging of $beq_target_calc.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_beq_target_calc_a7 &lt;= Pipelined_CPU_beq_target_calc_a6;

         </span><span class="tlx_comments">// Staging of $beq_type.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_beq_type_a6 &lt;= Pipelined_CPU_beq_type_a5;

         </span><span class="tlx_comments">// Staging of $funct.
         </span><span class="tlx_staging">always_ff @(posedge clkP_Pipelined_CPU_valid_instr_a6) Pipelined_CPU_funct_a6[5:0] &lt;= w_Pipelined_CPU_funct_a5[5:0];

         </span><span class="tlx_comments">// Staging of $imm.
         </span><span class="tlx_staging">always_ff @(posedge clkP_Pipelined_CPU_valid_instr_a6) Pipelined_CPU_imm_a6[7:0] &lt;= w_Pipelined_CPU_imm_a5[7:0];

         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_imm_x4_a5 = `WHEN(Pipelined_CPU_valid_instr_a5) w_Pipelined_CPU_imm_x4_a5;
         </span><span class="tlx_comments">// Staging of $imm_x4.
         </span><span class="tlx_staging">always_ff @(posedge clkP_Pipelined_CPU_valid_instr_a6) Pipelined_CPU_imm_x4_a6[7:0] &lt;= Pipelined_CPU_imm_x4_a5[7:0];

         </span><span class="tlx_comments">// Staging of $instr.
         </span><span class="tlx_staging">always_ff @(posedge clkP_Pipelined_CPU_valid_instr_a5) Pipelined_CPU_instr_a5[31:0] &lt;= w_Pipelined_CPU_instr_a4[31:0];
         always_ff @(posedge clkP_Pipelined_CPU_valid_instr_a6) Pipelined_CPU_instr_a6[31:11] &lt;= Pipelined_CPU_instr_a5[31:11];
         always_ff @(posedge clkP_Pipelined_CPU_valid_instr_a7) Pipelined_CPU_instr_a7[31:11] &lt;= Pipelined_CPU_instr_a6[31:11];
         always_ff @(posedge clkP_Pipelined_CPU_valid_instr_a8) Pipelined_CPU_instr_a8[31:16] &lt;= Pipelined_CPU_instr_a7[31:16];

         </span><span class="tlx_comments">// Staging of $jtype.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_jtype_a6 &lt;= Pipelined_CPU_jtype_a5;

         </span><span class="tlx_comments">// Staging of $lb_type.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_lb_type_a6 &lt;= Pipelined_CPU_lb_type_a5;
         always_ff @(posedge clk) Pipelined_CPU_lb_type_a7 &lt;= Pipelined_CPU_lb_type_a6;
         always_ff @(posedge clk) Pipelined_CPU_lb_type_a8 &lt;= Pipelined_CPU_lb_type_a7;

         </span><span class="tlx_comments">// Staging of $mem_read.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_mem_read_a2 &lt;= Pipelined_CPU_mem_read_a1;
         always_ff @(posedge clk) Pipelined_CPU_mem_read_a3 &lt;= Pipelined_CPU_mem_read_a2;

         </span><span class="tlx_comments">// Staging of $mem_type.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_mem_type_a6 &lt;= Pipelined_CPU_mem_type_a5;
         always_ff @(posedge clk) Pipelined_CPU_mem_type_a7 &lt;= Pipelined_CPU_mem_type_a6;

         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_memdata_a1 = `WHEN(Pipelined_CPU_mem_read_a1) w_Pipelined_CPU_memdata_a1;
         </span><span class="tlx_comments">// Staging of $memdata.
         </span><span class="tlx_staging">always_ff @(posedge clkP_Pipelined_CPU_mem_read_a2) Pipelined_CPU_memdata_a2[WIDTH-1:0] &lt;= Pipelined_CPU_memdata_a1[WIDTH-1:0];
         always_ff @(posedge clkP_Pipelined_CPU_mem_read_a3) Pipelined_CPU_memdata_a3[WIDTH-1:0] &lt;= Pipelined_CPU_memdata_a2[WIDTH-1:0];
         always_ff @(posedge clkP_Pipelined_CPU_mem_read_a4) Pipelined_CPU_memdata_a4[WIDTH-1:0] &lt;= Pipelined_CPU_memdata_a3[WIDTH-1:0];

         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_op_a5 = `WHEN(Pipelined_CPU_valid_instr_a5) w_Pipelined_CPU_op_a5;
         </span><span class="tlx_comments">// Staging of $rd1.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_rd1_a6[WIDTH-1:0] &lt;= Pipelined_CPU_rd1_a5[WIDTH-1:0];

         </span><span class="tlx_comments">// Staging of $rd2.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_rd2_a6[WIDTH-1:0] &lt;= Pipelined_CPU_rd2_a5[WIDTH-1:0];
         always_ff @(posedge clk) Pipelined_CPU_rd2_a7[WIDTH-1:0] &lt;= Pipelined_CPU_rd2_a6[WIDTH-1:0];

         </span><span class="tlx_comments">// Staging of $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_reset_a1 &lt;= Pipelined_CPU_reset_a0;

         </span><span class="tlx_comments">// Staging of $rtype.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_rtype_a6 &lt;= Pipelined_CPU_rtype_a5;
         always_ff @(posedge clk) Pipelined_CPU_rtype_a7 &lt;= Pipelined_CPU_rtype_a6;

         </span><span class="tlx_comments">// Staging of $sb_type.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_sb_type_a6 &lt;= Pipelined_CPU_sb_type_a5;
         always_ff @(posedge clk) Pipelined_CPU_sb_type_a7 &lt;= Pipelined_CPU_sb_type_a6;

         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_src_a_a6 = `WHEN(Pipelined_CPU_alu_valid_a6) w_Pipelined_CPU_src_a_a6;
         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_src_b_a6 = `WHEN(Pipelined_CPU_alu_valid_a6) w_Pipelined_CPU_src_b_a6;
         </span><span class="tlx_comments">// Staging of $valid_instr.
         </span><span class="tlx_staging">always_ff @(posedge clk) Pipelined_CPU_valid_instr_a1 &lt;= Pipelined_CPU_valid_instr_a0;
         always_ff @(posedge clk) Pipelined_CPU_valid_instr_a2 &lt;= Pipelined_CPU_valid_instr_a1;
         always_ff @(posedge clk) Pipelined_CPU_valid_instr_a3 &lt;= Pipelined_CPU_valid_instr_a2;
         always_ff @(posedge clk) Pipelined_CPU_valid_instr_a4 &lt;= Pipelined_CPU_valid_instr_a3;
         always_ff @(posedge clk) Pipelined_CPU_valid_instr_a5 &lt;= Pipelined_CPU_valid_instr_a4;
         always_ff @(posedge clk) Pipelined_CPU_valid_instr_a6 &lt;= Pipelined_CPU_valid_instr_a5;
         always_ff @(posedge clk) Pipelined_CPU_valid_instr_a7 &lt;= Pipelined_CPU_valid_instr_a6;

         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_wa_a5 = `WHEN(Pipelined_CPU_regwrite_a5) w_Pipelined_CPU_wa_a5;
         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_wd_a5 = `WHEN(Pipelined_CPU_regwrite_a5) w_Pipelined_CPU_wd_a5;
         </span><span class="tlx_comments">// Inject X when invalid.
         </span><span class="tlx_validity">assign Pipelined_CPU_zero_a6 = `WHEN(Pipelined_CPU_alu_valid_a6) w_Pipelined_CPU_zero_a6;



   </span><span class="tlx_comments">//
   // Scope: &gt;unpipelined
   //


      //
      // Scope: |cpu
      //

         // Staging of $Pc.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_Pc_a1[WIDTH-1:0] &lt;= Unpipelined_CPU_Pc_a0[WIDTH-1:0];

         </span><span class="tlx_comments">// Staging of $alu_out.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_alu_out_a7[WIDTH-1:0] &lt;= Unpipelined_CPU_alu_out_a6[WIDTH-1:0];

         </span><span class="tlx_comments">// Staging of $beq_target_calc.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_beq_target_calc_a7 &lt;= Unpipelined_CPU_beq_target_calc_a6;

         </span><span class="tlx_comments">// Staging of $instr.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_instr_a5[31:0] &lt;= Unpipelined_CPU_instr_a4[31:0];

         </span><span class="tlx_comments">// Staging of $lb_type.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_lb_type_a6 &lt;= Unpipelined_CPU_lb_type_a5;
         always_ff @(posedge clk) Unpipelined_CPU_lb_type_a7 &lt;= Unpipelined_CPU_lb_type_a6;

         </span><span class="tlx_comments">// Staging of $memdata.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_memdata_a2[WIDTH-1:0] &lt;= Unpipelined_CPU_memdata_a1[WIDTH-1:0];
         always_ff @(posedge clk) Unpipelined_CPU_memdata_a3[WIDTH-1:0] &lt;= Unpipelined_CPU_memdata_a2[WIDTH-1:0];
         always_ff @(posedge clk) Unpipelined_CPU_memdata_a4[WIDTH-1:0] &lt;= Unpipelined_CPU_memdata_a3[WIDTH-1:0];

         </span><span class="tlx_comments">// Staging of $rd1.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_rd1_a6[WIDTH-1:0] &lt;= Unpipelined_CPU_rd1_a5[WIDTH-1:0];

         </span><span class="tlx_comments">// Staging of $rd2.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_rd2_a6[WIDTH-1:0] &lt;= Unpipelined_CPU_rd2_a5[WIDTH-1:0];

         </span><span class="tlx_comments">// Staging of $reset.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_reset_a1 &lt;= Unpipelined_CPU_reset_a0;

         </span><span class="tlx_comments">// Staging of $valid_instr.
         </span><span class="tlx_staging">always_ff @(posedge clk) Unpipelined_CPU_valid_instr_a1 &lt;= Unpipelined_CPU_valid_instr_a0;
         always_ff @(posedge clk) Unpipelined_CPU_valid_instr_a2 &lt;= Unpipelined_CPU_valid_instr_a1;
         always_ff @(posedge clk) Unpipelined_CPU_valid_instr_a3 &lt;= Unpipelined_CPU_valid_instr_a2;
         always_ff @(posedge clk) Unpipelined_CPU_valid_instr_a4 &lt;= Unpipelined_CPU_valid_instr_a3;
         always_ff @(posedge clk) Unpipelined_CPU_valid_instr_a5 &lt;= Unpipelined_CPU_valid_instr_a4;
         always_ff @(posedge clk) Unpipelined_CPU_valid_instr_a6 &lt;= Unpipelined_CPU_valid_instr_a5;
         always_ff @(posedge clk) Unpipelined_CPU_valid_instr_a7 &lt;= Unpipelined_CPU_valid_instr_a6;
         always_ff @(posedge clk) Unpipelined_CPU_valid_instr_a8 &lt;= Unpipelined_CPU_valid_instr_a7;






</span><span class="tlx_comments">//
// Gated clocks.
//



   //
   // Scope: &gt;pipelined
   //


      //
      // Scope: |cpu
      //

</span><span class="tlx_validity">         clk_gate gen_clkP_Pipelined_CPU_alu_valid_a7(clkP_Pipelined_CPU_alu_valid_a7, clk, 1'b1, (Pipelined_CPU_alu_valid_a6 ? 1'b1 : 1'bx), 1'b0);
         clk_gate gen_clkP_Pipelined_CPU_mem_read_a2(clkP_Pipelined_CPU_mem_read_a2, clk, 1'b1, (Pipelined_CPU_mem_read_a1 ? 1'b1 : 1'bx), 1'b0);
         clk_gate gen_clkP_Pipelined_CPU_mem_read_a3(clkP_Pipelined_CPU_mem_read_a3, clk, 1'b1, (Pipelined_CPU_mem_read_a2 ? 1'b1 : 1'bx), 1'b0);
         clk_gate gen_clkP_Pipelined_CPU_mem_read_a4(clkP_Pipelined_CPU_mem_read_a4, clk, 1'b1, (Pipelined_CPU_mem_read_a3 ? 1'b1 : 1'bx), 1'b0);
         clk_gate gen_clkP_Pipelined_CPU_valid_instr_a5(clkP_Pipelined_CPU_valid_instr_a5, clk, 1'b1, (Pipelined_CPU_valid_instr_a4 ? 1'b1 : 1'bx), 1'b0);
         clk_gate gen_clkP_Pipelined_CPU_valid_instr_a6(clkP_Pipelined_CPU_valid_instr_a6, clk, 1'b1, (Pipelined_CPU_valid_instr_a5 ? 1'b1 : 1'bx), 1'b0);
         clk_gate gen_clkP_Pipelined_CPU_valid_instr_a7(clkP_Pipelined_CPU_valid_instr_a7, clk, 1'b1, (Pipelined_CPU_valid_instr_a6 ? 1'b1 : 1'bx), 1'b0);
         clk_gate gen_clkP_Pipelined_CPU_valid_instr_a8(clkP_Pipelined_CPU_valid_instr_a8, clk, 1'b1, (Pipelined_CPU_valid_instr_a7 ? 1'b1 : 1'bx), 1'b0);



</span>
</pre>
        </div>
        <div id="tlx_div" class="cell code left bottom">

<pre>
<span class="tlx_structure">\TLV_version 1c: tl-x.org
\SV
</span><span class="tlx_comments">/*
Copyright (c) 2015, Steven F. Hoover

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * The name of Steven F. Hoover
      may not be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/




// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// THIS IS NOT CURRENT W/ LATEST EP VERSION
// EP IS CURRENTLY THE MASTER
// DO NOT EDIT W/O UPDATING
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!






// Based on an example by Max Yi and David Harris 12/9/03


// Eliminate:

// states and instructions

  </span><span class="tlx_untouched">typedef enum logic [3:0] {FETCH1 = 4'b0000, FETCH2, FETCH3, FETCH4,
                            DECODE, MEMADR, LBRD, LBWR, SBWR,
                            RTYPEEX, RTYPEWR, BEQEX, JEX} statetype;
  typedef enum logic [5:0] {LB    = 6'b100000,
                            SB    = 6'b101000,
                            RTYPE = 6'b000000,
                            BEQ   = 6'b000100,
                            J     = 6'b000010} opcode;


</span><span class="tlx_comments">// testbench
</span><span class="tlx_untouched">module testbench #(parameter WIDTH = 8, REGBITS = 3)();

  logic done, done_tlv;
  logic [15:0] cyc;

  logic             clk;
  logic             reset;
  logic             memread, memwrite, memread_tlv, memwrite_tlv;
  logic [WIDTH-1:0] adr, writedata, adr_tlv, writedata_tlv;
  logic [WIDTH-1:0] memdata, memdata_tlv;

  </span><span class="tlx_comments">// instantiate devices to be tested
  </span><span class="tlx_untouched">mips #(WIDTH,REGBITS) dut(clk, reset, memdata, memread, 
                            memwrite, adr, writedata);
  mips_tlv #(WIDTH,REGBITS) dut_tlv(clk, reset, memdata_tlv, memread_tlv,
                                    memwrite_tlv, adr_tlv, writedata_tlv);

  </span><span class="tlx_comments">// external memory for code and data
  </span><span class="tlx_untouched">exmemory #(WIDTH) exmem(clk, memwrite, adr, writedata, memdata);
  </span><span class="tlx_comments">// external memory for code and data
  </span><span class="tlx_untouched">exmemory #(WIDTH) exmem_tlv(clk, memwrite_tlv, adr_tlv, writedata_tlv, memdata_tlv);

  </span><span class="tlx_comments">// initialize test
  </span><span class="tlx_untouched">initial
    begin
      $dumpfile(&quot;dump.vcd&quot;); $dumpvars;
      reset &lt;= 1; # 102; reset &lt;= 0;
      done &lt;= 0;
      done_tlv &lt;= 0;
      cyc &lt;= 0;
    end

  </span><span class="tlx_comments">// generate clock to sequence tests
  </span><span class="tlx_untouched">always
    begin
      clk &lt;= 1; # 5; clk &lt;= 0; # 5;
    end

  always@(negedge clk)
    begin
      cyc &lt;= cyc + 1;
      if(memwrite)
        assert(adr == 76 &amp; writedata == 7) begin
          $display(&quot;Verilog Simulation completely successfully @ cyc %d.&quot;, cyc);
          done &lt;= 1'b1;
        end
        else $error(&quot;Simulation Failed.&quot;);
      if(memwrite_tlv)
        assert(adr_tlv == 76 &amp; writedata_tlv == 7) begin
          $display(&quot;TLV SIMULATION COMPLETED Successfully!!!!!!!!!!!!!!!!!!!!!!!!&quot;);
          done_tlv &lt;= 1'b1;
        end
        else $error(&quot;SIMULATION FAILED!!!!!!!!!!!!!!!!!!!!!!!&quot;);
      if ((done &amp;&amp; done_tlv) || (cyc &gt; 300))
        $finish;
    end
endmodule



</span><span class="tlx_comments">// Memory (an SV library component)

// external memory accessed by MIPS
</span><span class="tlx_untouched">module exmemory #(parameter WIDTH = 8)
                 (input  logic             clk,
                  input  logic             memwrite,
                  input  logic [WIDTH-1:0] adr, writedata,
                  output logic [WIDTH-1:0] memdata);

  logic [31:0]      mem [2**(WIDTH-2)-1:0];
  logic [31:0]      word;
  logic [1:0]       bytesel;
  logic [WIDTH-2:0] wordadr;

  initial
    $readmemh(&quot;../../../examples/mips/memfile.dat&quot;, mem);

  assign bytesel = adr[1:0];
  assign wordadr = adr[WIDTH-1:2];

  </span><span class="tlx_comments">// read and write bytes from 32-bit word
  </span><span class="tlx_untouched">always @(posedge clk)
    if(memwrite) 
      case (bytesel)
        2'b00: mem[wordadr][7:0]   &lt;= writedata;
        2'b01: mem[wordadr][15:8]  &lt;= writedata;
        2'b10: mem[wordadr][23:16] &lt;= writedata;
        2'b11: mem[wordadr][31:24] &lt;= writedata;
      endcase

   assign word = mem[wordadr];
   always_comb
     case (bytesel)
       2'b00: memdata = word[7:0];
       2'b01: memdata = word[15:8];
       2'b10: memdata = word[23:16];
       2'b11: memdata = word[31:24];
     endcase
endmodule

  typedef enum logic [5:0] {ADD = 6'b100000,
                            SUB = 6'b100010,
                            AND = 6'b100100,
                            OR  = 6'b100101,
                            SLT = 6'b101010} functcode;


</span><span class="tlx_comments">// simplified MIPS processor
</span><span class="tlx_untouched">module mips_tlv #(parameter WIDTH = 8, REGBITS = 3)
             (input  logic             clk, reset, 
              input  logic [WIDTH-1:0] memdata, 
              output logic             memread, memwrite, 
              output logic [WIDTH-1:0] adr, writedata);



</span><span class="tlx_structure">\TLV

   &gt;unpipelined
      
      |cpu
         </span><span class="tlx_staging">@0
            </span><span class="tlx_logic">$reset = *reset;
            
            </span><span class="tlx_comments">// Ready for next instruction?
            </span><span class="tlx_logic">$valid_instr = !$reset &amp;&amp;
                           (%+1$reset ||   </span><span class="tlx_comments">// Valid immediately after reset
                            </span><span class="tlx_logic">(%+6$valid_instr &amp;&amp; (%+5$beq_type || %+5$jtype)) ||  </span><span class="tlx_comments">// Branch &amp; jump
                            </span><span class="tlx_logic">(%+7$valid_instr &amp;&amp; (%+5$sb_type || %+5$rtype)) ||   </span><span class="tlx_comments">// Store &amp; arith
                            </span><span class="tlx_logic">(%+8$valid_instr &amp;&amp; %+5$lb_type)                     </span><span class="tlx_comments">// Load
                           </span><span class="tlx_logic">);
         </span><span class="tlx_staging">@1  </span><span class="tlx_comments">// Fetch PC byte
            </span><span class="tlx_logic">$fetch = $valid_instr || %+1$valid_instr || %+2$valid_instr || %+3$valid_instr;

            </span><span class="tlx_comments">// Memory read/write.
            //*adr = (%+6$valid_instr &amp;&amp; %+4$mem_type) ? %+6$alu_out : $Pc;
            //*memread = $fetch || %+6$valid_instr &amp;&amp; %+4$lb_type;
            </span><span class="tlx_logic">$memdata[WIDTH-1:0] = *memdata;

            </span><span class="tlx_comments">// Next PC
            </span><span class="tlx_logic">%next$Pc[WIDTH-1:0] = $reset                       ? '0          :
                                  $fetch                       ? %+5$alu_out :
                                  %+5$valid_instr &amp;&amp; %+4$jtype ? %+4$imm_x4  :
                                  %+6$beq_update_pc            ? %+6$alu_out :
                                  $RETAIN;
         </span><span class="tlx_staging">@4
            
            </span><span class="tlx_comments">// Combine instruction bytes.
            </span><span class="tlx_logic">$instr[31:0] = %-4$reset    ? '0 :
                           $valid_instr ? {%-3$memdata, %-2$memdata, %-1$memdata, $memdata} :
                                          $RETAIN;
         
         </span><span class="tlx_comments">// decode/reg fetch
         </span><span class="tlx_staging">@5
            </span><span class="tlx_comments">// Instruction fields:
            </span><span class="tlx_logic">$imm[7:0] = $instr[7:0];
            $imm_x4[7:0] = {$instr[5:0], 2'b00};
            $op[5:0] = $instr[31:26];
            $funct[5:0] = $instr[5:0];
            
            </span><span class="tlx_comments">// Operand decode:
            </span><span class="tlx_logic">$rtype    = $op == 6'b000000;
            $mem_type = $op[5];
            $lb_type  = $mem_type &amp;&amp; !$op[3];
            $sb_type  = $mem_type &amp;&amp;  $op[3];
            $beq_type = $op[2];
            $jtype    = $op[1];
         </span><span class="tlx_staging">@6
            </span><span class="tlx_comments">// The pipeline is utilized the cycle before a beq.
            </span><span class="tlx_logic">$beq_target_calc = %next$valid_instr &amp;&amp; %next$beq_type;
         </span><span class="tlx_staging">@7
            </span><span class="tlx_logic">$beq_update_pc = $beq_target_calc &amp;&amp; %next$zero;

         </span><span class="tlx_staging">@5
            </span><span class="tlx_comments">// Register access:
            </span><span class="tlx_logic">$ra1[REGBITS-1:0] = $instr[REGBITS+20:21];
            $ra2[REGBITS-1:0] = $instr[REGBITS+15:16];
            $wa[REGBITS-1:0] = (%+2$valid_instr &amp;&amp; $rtype)
                    ? $instr[REGBITS+10:11]   </span><span class="tlx_comments">// %+2
                    </span><span class="tlx_logic">: $instr[REGBITS+15:16];
            $wd[WIDTH-1:0] = %+2$lb_type ? %-3$memdata : %+2$alu_out;
            $regwrite = (%+3$valid_instr &amp;&amp; $lb_type) || (%+2$valid_instr &amp;&amp; $rtype);
            regfile #(WIDTH,REGBITS) rf(clk, $regwrite, $ra1, $ra2,
                                        $wa, $wd, $$rd1[WIDTH-1:0], $$rd2[WIDTH-1:0]);

         </span><span class="tlx_comments">// ALU ($src_a, $src_b) -&gt; ($alu_rslt, $zero)
         //
            
         // ALU sources
         </span><span class="tlx_staging">@6
            </span><span class="tlx_logic">$src_a[WIDTH-1:0] = $valid_instr ? $rd1 : %-5$Pc;
            $src_b[WIDTH-1:0] = 
                %-5$fetch                         ? 1       :     </span><span class="tlx_comments">// Next byte of instr
                </span><span class="tlx_logic">$beq_target_calc                  ? %-1$imm_x4 :  </span><span class="tlx_comments">// Branch target
                </span><span class="tlx_logic">%-1$mem_type                      ? %-1$imm :     </span><span class="tlx_comments">// Mem addr calc
                                                    </span><span class="tlx_logic">$rd2;         </span><span class="tlx_comments">// ALU instr
            
            </span><span class="tlx_logic">$alu_op[1:0] = $valid_instr ? {%-1$rtype, %-1$beq_type} : 2'b00;
            aludec ac($alu_op, %-1$funct, $$alu_control[2:0]);
            
            </span><span class="tlx_comments">// ALU
            </span><span class="tlx_logic">alu #(WIDTH) alunit($src_a, $src_b, $alu_control, $$alu_out[WIDTH-1:0], $$zero);
         </span><span class="tlx_staging">@7
            </span><span class="tlx_comments">//*memwrite = *reset ? 1'b0 // avoid writing 'X
            //                   : $valid_instr &amp;&amp; $sb_type;
         </span><span class="tlx_staging">@6
            </span><span class="tlx_comments">//*writedata = $rd2;
      
      
   </span><span class="tlx_structure">&gt;pipelined
         
      |cpu
         </span><span class="tlx_staging">@0
            </span><span class="tlx_logic">$reset = *reset;
            
            </span><span class="tlx_comments">// Ready for next instruction?
            </span><span class="tlx_logic">$valid_instr = !$reset &amp;&amp;
                           (%+1$reset ||   </span><span class="tlx_comments">// Valid immediately after reset
                            </span><span class="tlx_logic">(%+6$beq_type || %+6$jtype) ||  </span><span class="tlx_comments">// Branch &amp; jump
                            </span><span class="tlx_logic">(%+7$sb_type || %+7$rtype) ||   </span><span class="tlx_comments">// Store &amp; arith
                            </span><span class="tlx_logic">%+8$lb_type                     </span><span class="tlx_comments">// Load
                           </span><span class="tlx_logic">);
         </span><span class="tlx_staging">@1  </span><span class="tlx_comments">// Fetch PC byte
            </span><span class="tlx_logic">$fetch = $valid_instr || %+1$valid_instr || %+2$valid_instr || %+3$valid_instr;

            </span><span class="tlx_comments">// Memory read/write.
            </span><span class="tlx_logic">*adr = %+6$mem_type ? %+6$alu_out : $Pc;
            $mem_read = $fetch || %+6$lb_type;
            *memread = $mem_read;
            </span><span class="tlx_validity">?$mem_read
               </span><span class="tlx_logic">$memdata[WIDTH-1:0] = *memdata;

            </span><span class="tlx_comments">// Next PC
            </span><span class="tlx_logic">%next$Pc[WIDTH-1:0] = $reset                       ? '0          :
                                  $fetch                       ? %+5$alu_out :
                                  %+5$jtype                    ? %+5$imm_x4  :
                                  %+6$beq_update_pc            ? %+6$alu_out :
                                  $RETAIN;
         </span><span class="tlx_staging">@4
            </span><span class="tlx_comments">// Combine instruction bytes.
            </span><span class="tlx_validity">?$valid_instr
               </span><span class="tlx_logic">$instr[31:0] = {%-3$memdata, %-2$memdata, %-1$memdata, $memdata} `BOGUS_USE($RETAIN);  </span><span class="tlx_comments">// BUG WORKAROUND (fixed, but not in EP)!!!!
         
         // decode/reg fetch
         </span><span class="tlx_staging">@5
            </span><span class="tlx_comments">// Characterize the transaction
            
            </span><span class="tlx_validity">?$valid_instr
               </span><span class="tlx_comments">// Instruction fields:
               </span><span class="tlx_logic">$imm[7:0] = $instr[7:0];
               $imm_x4[7:0] = {$instr[5:0], 2'b00};
               $op[5:0] = $instr[31:26];
               $funct[5:0] = $instr[5:0];
            
            </span><span class="tlx_comments">// Operand decode:
            </span><span class="tlx_logic">$rtype    = $valid_instr &amp;&amp; ($op == 6'b000000);
            $mem_type = $valid_instr &amp;&amp;  $op[5];
            $lb_type  = $mem_type &amp;&amp; !$op[3];
            $sb_type  = $mem_type &amp;&amp;  $op[3];
            $beq_type = $valid_instr &amp;&amp; $op[2];
            $jtype    = $valid_instr &amp;&amp; $op[1];

         </span><span class="tlx_staging">@6
            </span><span class="tlx_comments">// The pipeline is utilized the cycle before a beq.
            </span><span class="tlx_logic">$beq_target_calc = %next$valid_instr &amp;&amp; %next$beq_type;
         </span><span class="tlx_staging">@7
            </span><span class="tlx_logic">$beq_update_pc = $beq_target_calc &amp;&amp; %next$zero;

         </span><span class="tlx_staging">@5
            </span><span class="tlx_comments">// Register access:
            </span><span class="tlx_logic">$ra1[REGBITS-1:0] = $instr[REGBITS+20:21];
            $ra2[REGBITS-1:0] = $instr[REGBITS+15:16];
            </span><span class="tlx_validity">?$regwrite
               </span><span class="tlx_logic">$wa[REGBITS-1:0] = %+2$rtype
                       ? %+2$instr[REGBITS+10:11]   </span><span class="tlx_comments">// %+2
                       </span><span class="tlx_logic">: %+3$instr[REGBITS+15:16];
               $wd[WIDTH-1:0] = %+2$rtype ? %+2$alu_out : %-3$memdata;
            $regwrite = %+3$lb_type || %+2$rtype;
            regfile #(WIDTH,REGBITS) rf2(clk, $regwrite, $ra1, $ra2,
                                        $wa, $wd, $$rd1[WIDTH-1:0], $$rd2[WIDTH-1:0]);

         </span><span class="tlx_comments">// ALU ($src_a, $src_b) -&gt; ($alu_rslt, $zero)
         //
            
         // ALU sources
         </span><span class="tlx_staging">@6
            </span><span class="tlx_logic">$alu_valid = $valid_instr ||    </span><span class="tlx_comments">// any instr
                         </span><span class="tlx_logic">%next$beq_type ||  </span><span class="tlx_comments">// branch target
                         </span><span class="tlx_logic">%-5$fetch;         </span><span class="tlx_comments">// next PC byte
            </span><span class="tlx_validity">?$alu_valid
               </span><span class="tlx_logic">$src_a[WIDTH-1:0] = $valid_instr ? $rd1 : %-5$Pc;
               $src_b[WIDTH-1:0] = 
                   %-5$fetch                         ? 1       :       </span><span class="tlx_comments">// Next byte of instr
                   </span><span class="tlx_logic">$beq_target_calc                  ? %next$imm_x4 :  </span><span class="tlx_comments">// Branch target
                   </span><span class="tlx_logic">$mem_type                         ? $imm :          </span><span class="tlx_comments">// Mem addr calc
                                                       </span><span class="tlx_logic">$rd2;           </span><span class="tlx_comments">// ALU instr
            
               </span><span class="tlx_logic">$alu_op[1:0] = $valid_instr ? {$rtype, $beq_type} : 2'b00;
               aludec ac2($alu_op, $funct, $$alu_control[2:0]);
            
               </span><span class="tlx_comments">// ALU
               </span><span class="tlx_logic">alu #(WIDTH) alunit2($src_a, $src_b, $alu_control, $$alu_out[WIDTH-1:0], $$zero);
            
         </span><span class="tlx_staging">@7
            </span><span class="tlx_logic">*memwrite = *reset ? 1'b0 </span><span class="tlx_comments">// avoid writing 'X
                               </span><span class="tlx_logic">: $sb_type;
            </span><span class="tlx_validity">?$sb_type
               </span><span class="tlx_logic">*writedata = $rd2;


</span><span class="tlx_structure">\SV
</span><span class="tlx_untouched">endmodule




</span><span class="tlx_comments">// And this will all go away:

// simplified MIPS processor
</span><span class="tlx_untouched">module mips #(parameter WIDTH = 8, REGBITS = 3)
             (input  logic             clk, pre_reset, 
              input  logic [WIDTH-1:0] memdata, 
              output logic             memread, memwrite, 
              output logic [WIDTH-1:0] adr, writedata);

   logic [31:0] instr;
   logic        zero, alusrca, memtoreg, iord, pcen, regwrite, regdst;
   logic [1:0]  pcsrc, alusrcb;
   logic [3:0]  irwrite;
   logic [2:0]  alucontrol;
   logic [5:0]  op, funct;
   logic reset;

   flop #(1) rst_flp(clk, pre_reset, reset);
   

   assign op = instr[31:26];      
   assign funct = instr[5:0];  
      
   controller  cont(clk, reset, op, funct, zero, memread, memwrite, 
                    alusrca, memtoreg, iord, pcen, regwrite, regdst,
                    pcsrc, alusrcb, alucontrol, irwrite);
   datapath    #(WIDTH, REGBITS) 
               dp(clk, reset, memdata, alusrca, memtoreg, iord, pcen,
                  regwrite, regdst, pcsrc, alusrcb, irwrite, alucontrol,
                  zero, instr, adr, writedata);
endmodule

module controller(input logic clk, reset, 
                  input  logic [5:0] op, funct,
                  input  logic       zero, 
                  output logic       memread, memwrite, alusrca,  
                  output logic       memtoreg, iord, pcen, 
                  output logic       regwrite, regdst, 
                  output logic [1:0] pcsrc, alusrcb,
                  output logic [2:0] alucontrol,
                  output logic [3:0] irwrite);

  statetype       state;
  logic           pcwrite, branch;
  logic     [1:0] aluop;

  </span><span class="tlx_comments">// control FSM
  </span><span class="tlx_untouched">statelogic statelog(clk, reset, op, state);
  outputlogic outputlog(state, memread, memwrite, alusrca,
                        memtoreg, iord, 
                        regwrite, regdst, pcsrc, alusrcb, irwrite, 
                        pcwrite, branch, aluop);

  </span><span class="tlx_comments">// other control decoding
  </span><span class="tlx_untouched">aludec  ac(aluop, funct, alucontrol);
  assign pcen = pcwrite | (branch &amp; zero); </span><span class="tlx_comments">// program counter enable
</span><span class="tlx_untouched">endmodule

module statelogic(input  logic       clk, reset,
                  input  logic [5:0] op,
                  output statetype   state);

  statetype nextstate;
  
  always_ff @(posedge clk)
    if (reset) state &lt;= FETCH1;
    else       state &lt;= nextstate;
    
  always_comb
    begin
      case (state)
        FETCH1:  nextstate = FETCH2;
        FETCH2:  nextstate = FETCH3;
        FETCH3:  nextstate = FETCH4;
        FETCH4:  nextstate = DECODE;
        DECODE:  case(op)
                   LB:      nextstate = MEMADR;
                   SB:      nextstate = MEMADR;
                   RTYPE:   nextstate = RTYPEEX;
                   BEQ:     nextstate = BEQEX;
                   J:       nextstate = JEX;
                   default: nextstate = FETCH1; </span><span class="tlx_comments">// should never happen
                 </span><span class="tlx_untouched">endcase
        MEMADR:  case(op)
                   LB:      nextstate = LBRD;
                   SB:      nextstate = SBWR;
                   default: nextstate = FETCH1; </span><span class="tlx_comments">// should never happen
                 </span><span class="tlx_untouched">endcase
        LBRD:    nextstate = LBWR;
        LBWR:    nextstate = FETCH1;
        SBWR:    nextstate = FETCH1;
        RTYPEEX: nextstate = RTYPEWR;
        RTYPEWR: nextstate = FETCH1;
        BEQEX:   nextstate = FETCH1;
        JEX:     nextstate = FETCH1;
        default: nextstate = FETCH1; </span><span class="tlx_comments">// should never happen
      </span><span class="tlx_untouched">endcase
    end
endmodule

module outputlogic(input statetype state,
                   output logic       memread, memwrite, alusrca,  
                   output logic       memtoreg, iord, 
                   output logic       regwrite, regdst, 
                   output logic [1:0] pcsrc, alusrcb,
                   output logic [3:0] irwrite,
                   output logic       pcwrite, branch,
                   output logic [1:0] aluop);

  always_comb
    begin
      </span><span class="tlx_comments">// set all outputs to zero, then 
      // conditionally assert just the appropriate ones
      </span><span class="tlx_untouched">irwrite = 4'b0000;
      pcwrite = 0; branch = 0;
      regwrite = 0; regdst = 0;
      memread = 0; memwrite = 0;
      alusrca = 0; alusrcb = 2'b00; aluop = 2'b00;
      pcsrc = 2'b00;
      iord = 0; memtoreg = 0;
      case (state)
        FETCH1: 
          begin
            memread = 1; 
            irwrite = 4'b0001; 
            alusrcb = 2'b01; 
            pcwrite = 1;
          end
        FETCH2: 
          begin
            memread = 1;
            irwrite = 4'b0010;
            alusrcb = 2'b01;
            pcwrite = 1;
          end
        FETCH3:
          begin
            memread = 1;
            irwrite = 4'b0100;
            alusrcb = 2'b01;
            pcwrite = 1;
          end
        FETCH4:
          begin
            memread = 1;
            irwrite = 4'b1000;
            alusrcb = 2'b01;
            pcwrite = 1;
          end
        DECODE: alusrcb = 2'b11;
        MEMADR:
          begin
            alusrca = 1;
            alusrcb = 2'b10;
          end
        LBRD:
          begin
            memread = 1;
            iord    = 1;
          end
        LBWR:
          begin
            regwrite = 1;
            memtoreg = 1;
          end
        SBWR:
          begin
            memwrite = 1;
            iord     = 1;
          end
        RTYPEEX: 
          begin
            alusrca = 1;
            aluop   = 2'b10;
          end
        RTYPEWR:
          begin
            regdst   = 1;
            regwrite = 1;
          end
        BEQEX:
          begin
            alusrca = 1;
            aluop   = 2'b01;
            branch  = 1;
            pcsrc   = 2'b01;
          end
        JEX:
          begin
            pcwrite  = 1;
            pcsrc    = 2'b10;
          end
      endcase
    end
endmodule

module aludec(input  logic [1:0] aluop, 
              input  logic [5:0] funct, 
              output logic [2:0] alucontrol);

  always_comb
    case (aluop)
      2'b00: alucontrol = 3'b010;  </span><span class="tlx_comments">// add for lb/sb/addi
      </span><span class="tlx_untouched">2'b01: alucontrol = 3'b110;  </span><span class="tlx_comments">// subtract (for beq)
      </span><span class="tlx_untouched">default: case(funct)      </span><span class="tlx_comments">// R-Type instructions
                 </span><span class="tlx_untouched">ADD: alucontrol = 3'b010;
                 SUB: alucontrol = 3'b110;
                 AND: alucontrol = 3'b000;
                 OR:  alucontrol = 3'b001;
                 SLT: alucontrol = 3'b111;
                 default:   alucontrol = 3'b101; </span><span class="tlx_comments">// should never happen
               </span><span class="tlx_untouched">endcase
    endcase
endmodule

module datapath #(parameter WIDTH = 8, REGBITS = 3)
                 (input  logic             clk, reset, 
                  input  logic [WIDTH-1:0] memdata, 
                  input  logic             alusrca, memtoreg, iord, 
                  input  logic             pcen, regwrite, regdst,
                  input  logic [1:0]       pcsrc, alusrcb, 
                  input  logic [3:0]       irwrite, 
                  input  logic [2:0]       alucontrol, 
                  output logic             zero, 
                  output logic [31:0]      instr, 
                  output logic [WIDTH-1:0] adr, writedata);

  logic [REGBITS-1:0] ra1, ra2, wa;
  logic [WIDTH-1:0]   pc, nextpc, data, rd1, rd2, wd, a, srca, 
                      srcb, aluresult, aluout, immx4;

  logic [WIDTH-1:0] CONST_ZERO = 0;
  logic [WIDTH-1:0] CONST_ONE =  1;

  </span><span class="tlx_comments">// shift left immediate field by 2
  </span><span class="tlx_untouched">assign immx4 = {instr[WIDTH-3:0],2'b00};

  </span><span class="tlx_comments">// register file address fields
  </span><span class="tlx_untouched">assign ra1 = instr[REGBITS+20:21];
  assign ra2 = instr[REGBITS+15:16];
  mux2       #(REGBITS) regmux(instr[REGBITS+15:16], 
                               instr[REGBITS+10:11], regdst, wa);

   </span><span class="tlx_comments">// independent of bit width, load instruction into four 8-bit registers over four cycles
  </span><span class="tlx_untouched">flopen     #(8)      ir0(clk, irwrite[0], memdata[7:0], instr[7:0]);
  flopen     #(8)      ir1(clk, irwrite[1], memdata[7:0], instr[15:8]);
  flopen     #(8)      ir2(clk, irwrite[2], memdata[7:0], instr[23:16]);
  flopen     #(8)      ir3(clk, irwrite[3], memdata[7:0], instr[31:24]);

  </span><span class="tlx_comments">// datapath
  </span><span class="tlx_untouched">flopenr    #(WIDTH)  pcreg(clk, reset, pcen, nextpc, pc);
  flop       #(WIDTH)  datareg(clk, memdata, data);
  flop       #(WIDTH)  areg(clk, rd1, a);
  flop       #(WIDTH)  wrdreg(clk, rd2, writedata);
  flop       #(WIDTH)  resreg(clk, aluresult, aluout);
  mux2       #(WIDTH)  adrmux(pc, aluout, iord, adr);
  mux2       #(WIDTH)  src1mux(pc, a, alusrca, srca);
  mux4       #(WIDTH)  src2mux(writedata, CONST_ONE, instr[WIDTH-1:0], 
                               immx4, alusrcb, srcb);
  mux3       #(WIDTH)  pcmux(aluresult, aluout, immx4, 
                             pcsrc, nextpc);
  mux2       #(WIDTH)  wdmux(aluout, data, memtoreg, wd);
  regfile    #(WIDTH,REGBITS) rf(clk, regwrite, ra1, ra2, 
                                 wa, wd, rd1, rd2);
  alu        #(WIDTH) alunit(srca, srcb, alucontrol, aluresult, zero);
endmodule

module alu #(parameter WIDTH = 8)
            (input  logic [WIDTH-1:0] a, b, 
             input  logic [2:0]       alucontrol, 
             output logic [WIDTH-1:0] result,
             output logic             zero);

  logic [WIDTH-1:0] b2, andresult, orresult, sumresult, sltresult;

  andN    andblock(a, b, andresult);
  orN     orblock(a, b, orresult);
  condinv binv(b, alucontrol[2], b2);
  adder   addblock(a, b2, alucontrol[2], sumresult);
  </span><span class="tlx_comments">// slt should be 1 if most significant bit of sum is 1
  </span><span class="tlx_untouched">assign sltresult = sumresult[WIDTH-1];

  mux4 resultmux(andresult, orresult, sumresult, sltresult, alucontrol[1:0], result);
  zerodetect #(WIDTH) zd(result, zero);
endmodule

module regfile #(parameter WIDTH = 8, REGBITS = 3)
                (input  logic               clk, 
                 input  logic               regwrite, 
                 input  logic [REGBITS-1:0] ra1, ra2, wa, 
                 input  logic [WIDTH-1:0]   wd, 
                 output logic [WIDTH-1:0]   rd1, rd2);

   logic [WIDTH-1:0] RAM [2**REGBITS-1:0];

  </span><span class="tlx_comments">// three ported register file
  // read two ports combinationally
  // write third port on rising edge of clock
  // register 0 hardwired to 0
  </span><span class="tlx_untouched">always @(posedge clk)
    if (regwrite) RAM[wa] &lt;= wd;

  assign rd1 = ra1 ? RAM[ra1] : 0;
  assign rd2 = ra2 ? RAM[ra2] : 0;
endmodule

module zerodetect #(parameter WIDTH = 8)
                   (input  logic [WIDTH-1:0] a, 
                    output logic             y);

   assign y = (a==0);
endmodule	

module flop #(parameter WIDTH = 8)
             (input  logic             clk, 
              input  logic [WIDTH-1:0] d, 
              output logic [WIDTH-1:0] q);

  always_ff @(posedge clk)
    q &lt;= d;
endmodule

module flopen #(parameter WIDTH = 8)
               (input  logic             clk, en,
                input  logic [WIDTH-1:0] d, 
                output logic [WIDTH-1:0] q);

  always_ff @(posedge clk)
    if (en) q &lt;= d;
endmodule

module flopenr #(parameter WIDTH = 8)
                (input  logic             clk, reset, en,
                 input  logic [WIDTH-1:0] d, 
                 output logic [WIDTH-1:0] q);
 
  always_ff @(posedge clk)
    if      (reset) q &lt;= 0;
    else if (en)    q &lt;= d;
endmodule

module mux2 #(parameter WIDTH = 8)
             (input  logic [WIDTH-1:0] d0, d1, 
              input  logic             s, 
              output logic [WIDTH-1:0] y);

  assign y = s ? d1 : d0; 
endmodule

module mux3 #(parameter WIDTH = 8)
             (input  logic [WIDTH-1:0] d0, d1, d2,
              input  logic [1:0]       s, 
              output logic [WIDTH-1:0] y);

  always_comb 
    casez (s)
      2'b00: y = d0;
      2'b01: y = d1;
      2'b1?: y = d2;
    endcase
endmodule

module mux4 #(parameter WIDTH = 8)
             (input  logic [WIDTH-1:0] d0, d1, d2, d3,
              input  logic [1:0]       s, 
              output logic [WIDTH-1:0] y);

  always_comb
    case (s)
      2'b00: y = d0;
      2'b01: y = d1;
      2'b10: y = d2;
      2'b11: y = d3;
    endcase
endmodule

module andN #(parameter WIDTH = 8)
             (input  logic [WIDTH-1:0] a, b,
              output logic [WIDTH-1:0] y);

  assign y = a &amp; b;
endmodule

module orN #(parameter WIDTH = 8)
            (input  logic [WIDTH-1:0] a, b,
             output logic [WIDTH-1:0] y);

  assign y = a | b;
endmodule

module inv #(parameter WIDTH = 8)
            (input  logic [WIDTH-1:0] a,
             output logic [WIDTH-1:0] y);

  assign y = ~a;
endmodule

module condinv #(parameter WIDTH = 8)
                (input  logic [WIDTH-1:0] a,
                 input  logic             invert,
                 output logic [WIDTH-1:0] y);

  logic [WIDTH-1:0] ab;

  inv  inverter(a, ab);
  mux2 invmux(a, ab, invert, y);
endmodule

module adder #(parameter WIDTH = 8)
              (input  logic [WIDTH-1:0] a, b,
               input  logic             cin,
               output logic [WIDTH-1:0] y);

  assign y = a + b + cin;
endmodule
</span>
</pre>
        </div>
        <div id="trans_div" class="cell code right bottom">

<pre>
<span class="tlx_comments">//_\TLV_version 1c: tl-x.org, generated by SandPiper(TM)

/*
Copyright (c) 2015, Steven F. Hoover

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * The name of Steven F. Hoover
      may not be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/




// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// THIS IS NOT CURRENT W/ LATEST EP VERSION
// EP IS CURRENTLY THE MASTER
// DO NOT EDIT W/O UPDATING
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!






// Based on an example by Max Yi and David Harris 12/9/03


// Eliminate:

// states and instructions

  </span><span class="tlx_untouched">typedef enum logic [3:0] {FETCH1 = 4'b0000, FETCH2, FETCH3, FETCH4,
                            DECODE, MEMADR, LBRD, LBWR, SBWR,
                            RTYPEEX, RTYPEWR, BEQEX, JEX} statetype;
  typedef enum logic [5:0] {LB    = 6'b100000,
                            SB    = 6'b101000,
                            RTYPE = 6'b000000,
                            BEQ   = 6'b000100,
                            J     = 6'b000010} opcode;


</span><span class="tlx_comments">// testbench
</span><span class="tlx_untouched">module testbench #(parameter WIDTH = 8, REGBITS = 3)();

  logic done, done_tlv;
  logic [15:0] cyc;

  logic             clk;
  logic             reset;
  logic             memread, memwrite, memread_tlv, memwrite_tlv;
  logic [WIDTH-1:0] adr, writedata, adr_tlv, writedata_tlv;
  logic [WIDTH-1:0] memdata, memdata_tlv;

  </span><span class="tlx_comments">// instantiate devices to be tested
  </span><span class="tlx_untouched">mips #(WIDTH,REGBITS) dut(clk, reset, memdata, memread, 
                            memwrite, adr, writedata);
  mips_tlv #(WIDTH,REGBITS) dut_tlv(clk, reset, memdata_tlv, memread_tlv,
                                    memwrite_tlv, adr_tlv, writedata_tlv);

  </span><span class="tlx_comments">// external memory for code and data
  </span><span class="tlx_untouched">exmemory #(WIDTH) exmem(clk, memwrite, adr, writedata, memdata);
  </span><span class="tlx_comments">// external memory for code and data
  </span><span class="tlx_untouched">exmemory #(WIDTH) exmem_tlv(clk, memwrite_tlv, adr_tlv, writedata_tlv, memdata_tlv);

  </span><span class="tlx_comments">// initialize test
  </span><span class="tlx_untouched">initial
    begin
      $dumpfile(&quot;dump.vcd&quot;); $dumpvars;
      reset &lt;= 1; # 102; reset &lt;= 0;
      done &lt;= 0;
      done_tlv &lt;= 0;
      cyc &lt;= 0;
    end

  </span><span class="tlx_comments">// generate clock to sequence tests
  </span><span class="tlx_untouched">always
    begin
      clk &lt;= 1; # 5; clk &lt;= 0; # 5;
    end

  always@(negedge clk)
    begin
      cyc &lt;= cyc + 1;
      if(memwrite)
        assert(adr == 76 &amp; writedata == 7) begin
          $display(&quot;Verilog Simulation completely successfully @ cyc %d.&quot;, cyc);
          done &lt;= 1'b1;
        end
        else $error(&quot;Simulation Failed.&quot;);
      if(memwrite_tlv)
        assert(adr_tlv == 76 &amp; writedata_tlv == 7) begin
          $display(&quot;TLV SIMULATION COMPLETED Successfully!!!!!!!!!!!!!!!!!!!!!!!!&quot;);
          done_tlv &lt;= 1'b1;
        end
        else $error(&quot;SIMULATION FAILED!!!!!!!!!!!!!!!!!!!!!!!&quot;);
      if ((done &amp;&amp; done_tlv) || (cyc &gt; 300))
        $finish;
    end
endmodule



</span><span class="tlx_comments">// Memory (an SV library component)

// external memory accessed by MIPS
</span><span class="tlx_untouched">module exmemory #(parameter WIDTH = 8)
                 (input  logic             clk,
                  input  logic             memwrite,
                  input  logic [WIDTH-1:0] adr, writedata,
                  output logic [WIDTH-1:0] memdata);

  logic [31:0]      mem [2**(WIDTH-2)-1:0];
  logic [31:0]      word;
  logic [1:0]       bytesel;
  logic [WIDTH-2:0] wordadr;

  initial
    $readmemh(&quot;../../../examples/mips/memfile.dat&quot;, mem);

  assign bytesel = adr[1:0];
  assign wordadr = adr[WIDTH-1:2];

  </span><span class="tlx_comments">// read and write bytes from 32-bit word
  </span><span class="tlx_untouched">always @(posedge clk)
    if(memwrite) 
      case (bytesel)
        2'b00: mem[wordadr][7:0]   &lt;= writedata;
        2'b01: mem[wordadr][15:8]  &lt;= writedata;
        2'b10: mem[wordadr][23:16] &lt;= writedata;
        2'b11: mem[wordadr][31:24] &lt;= writedata;
      endcase

   assign word = mem[wordadr];
   always_comb
     case (bytesel)
       2'b00: memdata = word[7:0];
       2'b01: memdata = word[15:8];
       2'b10: memdata = word[23:16];
       2'b11: memdata = word[31:24];
     endcase
endmodule

  typedef enum logic [5:0] {ADD = 6'b100000,
                            SUB = 6'b100010,
                            AND = 6'b100100,
                            OR  = 6'b100101,
                            SLT = 6'b101010} functcode;


</span><span class="tlx_comments">// simplified MIPS processor
</span><span class="tlx_untouched">module mips_tlv #(parameter WIDTH = 8, REGBITS = 3)
             (input  logic             clk, reset, 
              input  logic [WIDTH-1:0] memdata, 
              output logic             memread, memwrite, 
              output logic [WIDTH-1:0] adr, writedata);



</span><span class="tlx_structure">`include &quot;design_gen.sv&quot;

   </span><span class="tlx_comments">//_&gt;unpipelined
      
      //_|cpu
         //_@0
            </span><span class="tlx_logic">assign Unpipelined_CPU_reset_a0 = reset;
            
            </span><span class="tlx_comments">// Ready for next instruction?
            </span><span class="tlx_logic">assign Unpipelined_CPU_valid_instr_a0 = !Unpipelined_CPU_reset_a0 &amp;&amp;
                           (Unpipelined_CPU_reset_a1 ||   </span><span class="tlx_comments">// Valid immediately after reset
                            </span><span class="tlx_logic">(Unpipelined_CPU_valid_instr_a6 &amp;&amp; (Unpipelined_CPU_beq_type_a5 || Unpipelined_CPU_jtype_a5)) ||  </span><span class="tlx_comments">// Branch &amp; jump
                            </span><span class="tlx_logic">(Unpipelined_CPU_valid_instr_a7 &amp;&amp; (Unpipelined_CPU_sb_type_a5 || Unpipelined_CPU_rtype_a5)) ||   </span><span class="tlx_comments">// Store &amp; arith
                            </span><span class="tlx_logic">(Unpipelined_CPU_valid_instr_a8 &amp;&amp; Unpipelined_CPU_lb_type_a5)                     </span><span class="tlx_comments">// Load
                           </span><span class="tlx_logic">);
         </span><span class="tlx_comments">//_@1  // Fetch PC byte
            </span><span class="tlx_logic">assign Unpipelined_CPU_fetch_a1 = Unpipelined_CPU_valid_instr_a1 || Unpipelined_CPU_valid_instr_a2 || Unpipelined_CPU_valid_instr_a3 || Unpipelined_CPU_valid_instr_a4;

            </span><span class="tlx_comments">// Memory read/write.
            //*adr = (%+6$valid_instr &amp;&amp; %+4$mem_type) ? %+6$alu_out : $Pc;
            //*memread = $fetch || %+6$valid_instr &amp;&amp; %+4$lb_type;
            </span><span class="tlx_logic">assign Unpipelined_CPU_memdata_a1[WIDTH-1:0] = memdata;

            </span><span class="tlx_comments">// Next PC
            </span><span class="tlx_logic">assign Unpipelined_CPU_Pc_a0[WIDTH-1:0] = Unpipelined_CPU_reset_a1                       ? '0          :
                                  Unpipelined_CPU_fetch_a1                       ? Unpipelined_CPU_alu_out_a6 :
                                  Unpipelined_CPU_valid_instr_a6 &amp;&amp; Unpipelined_CPU_jtype_a5 ? Unpipelined_CPU_imm_x4_a5  :
                                  Unpipelined_CPU_beq_update_pc_a7            ? Unpipelined_CPU_alu_out_a7 :
                                  Unpipelined_CPU_Pc_a1[WIDTH-1:0];
         </span><span class="tlx_comments">//_@4
            
            // Combine instruction bytes.
            </span><span class="tlx_logic">assign Unpipelined_CPU_instr_a4[31:0] = Unpipelined_CPU_reset_a0    ? '0 :
                           Unpipelined_CPU_valid_instr_a4 ? {Unpipelined_CPU_memdata_a1, Unpipelined_CPU_memdata_a2, Unpipelined_CPU_memdata_a3, Unpipelined_CPU_memdata_a4} :
                                          Unpipelined_CPU_instr_a5[31:0];
         
         </span><span class="tlx_comments">// decode/reg fetch
         //_@5
            // Instruction fields:
            </span><span class="tlx_logic">assign Unpipelined_CPU_imm_a5[7:0] = Unpipelined_CPU_instr_a5[7:0];
            assign Unpipelined_CPU_imm_x4_a5[7:0] = {Unpipelined_CPU_instr_a5[5:0], 2'b00};
            assign Unpipelined_CPU_op_a5[5:0] = Unpipelined_CPU_instr_a5[31:26];
            assign Unpipelined_CPU_funct_a5[5:0] = Unpipelined_CPU_instr_a5[5:0];
            
            </span><span class="tlx_comments">// Operand decode:
            </span><span class="tlx_logic">assign Unpipelined_CPU_rtype_a5    = Unpipelined_CPU_op_a5 == 6'b000000;
            assign Unpipelined_CPU_mem_type_a5 = Unpipelined_CPU_op_a5[5];
            assign Unpipelined_CPU_lb_type_a5  = Unpipelined_CPU_mem_type_a5 &amp;&amp; !Unpipelined_CPU_op_a5[3];
            assign Unpipelined_CPU_sb_type_a5  = Unpipelined_CPU_mem_type_a5 &amp;&amp;  Unpipelined_CPU_op_a5[3];
            assign Unpipelined_CPU_beq_type_a5 = Unpipelined_CPU_op_a5[2];
            assign Unpipelined_CPU_jtype_a5    = Unpipelined_CPU_op_a5[1];
         </span><span class="tlx_comments">//_@6
            // The pipeline is utilized the cycle before a beq.
            </span><span class="tlx_logic">assign Unpipelined_CPU_beq_target_calc_a6 = Unpipelined_CPU_valid_instr_a5 &amp;&amp; Unpipelined_CPU_beq_type_a5;
         </span><span class="tlx_comments">//_@7
            </span><span class="tlx_logic">assign Unpipelined_CPU_beq_update_pc_a7 = Unpipelined_CPU_beq_target_calc_a7 &amp;&amp; Unpipelined_CPU_zero_a6;

         </span><span class="tlx_comments">//_@5
            // Register access:
            </span><span class="tlx_logic">assign Unpipelined_CPU_ra1_a5[REGBITS-1:0] = Unpipelined_CPU_instr_a5[REGBITS+20:21];
            assign Unpipelined_CPU_ra2_a5[REGBITS-1:0] = Unpipelined_CPU_instr_a5[REGBITS+15:16];
            assign Unpipelined_CPU_wa_a5[REGBITS-1:0] = (Unpipelined_CPU_valid_instr_a7 &amp;&amp; Unpipelined_CPU_rtype_a5)
                    ? Unpipelined_CPU_instr_a5[REGBITS+10:11]   </span><span class="tlx_comments">// %+2
                    </span><span class="tlx_logic">: Unpipelined_CPU_instr_a5[REGBITS+15:16];
            assign Unpipelined_CPU_wd_a5[WIDTH-1:0] = Unpipelined_CPU_lb_type_a7 ? Unpipelined_CPU_memdata_a2 : Unpipelined_CPU_alu_out_a7;
            assign Unpipelined_CPU_regwrite_a5 = (Unpipelined_CPU_valid_instr_a8 &amp;&amp; Unpipelined_CPU_lb_type_a5) || (Unpipelined_CPU_valid_instr_a7 &amp;&amp; Unpipelined_CPU_rtype_a5);
            regfile #(WIDTH,REGBITS) rf(clk, Unpipelined_CPU_regwrite_a5, Unpipelined_CPU_ra1_a5, Unpipelined_CPU_ra2_a5,
                                        Unpipelined_CPU_wa_a5, Unpipelined_CPU_wd_a5, Unpipelined_CPU_rd1_a5[WIDTH-1:0], Unpipelined_CPU_rd2_a5[WIDTH-1:0]);

         </span><span class="tlx_comments">// ALU ($src_a, $src_b) -&gt; ($alu_rslt, $zero)
         //
            
         // ALU sources
         //_@6
            </span><span class="tlx_logic">assign Unpipelined_CPU_src_a_a6[WIDTH-1:0] = Unpipelined_CPU_valid_instr_a6 ? Unpipelined_CPU_rd1_a6 : Unpipelined_CPU_Pc_a1;
            assign Unpipelined_CPU_src_b_a6[WIDTH-1:0] = 
                Unpipelined_CPU_fetch_a1                         ? 1       :     </span><span class="tlx_comments">// Next byte of instr
                </span><span class="tlx_logic">Unpipelined_CPU_beq_target_calc_a6                  ? Unpipelined_CPU_imm_x4_a5 :  </span><span class="tlx_comments">// Branch target
                </span><span class="tlx_logic">Unpipelined_CPU_mem_type_a5                      ? Unpipelined_CPU_imm_a5 :     </span><span class="tlx_comments">// Mem addr calc
                                                    </span><span class="tlx_logic">Unpipelined_CPU_rd2_a6;         </span><span class="tlx_comments">// ALU instr
            
            </span><span class="tlx_logic">assign Unpipelined_CPU_alu_op_a6[1:0] = Unpipelined_CPU_valid_instr_a6 ? {Unpipelined_CPU_rtype_a5, Unpipelined_CPU_beq_type_a5} : 2'b00;
            aludec ac(Unpipelined_CPU_alu_op_a6, Unpipelined_CPU_funct_a5, Unpipelined_CPU_alu_control_a6[2:0]);
            
            </span><span class="tlx_comments">// ALU
            </span><span class="tlx_logic">alu #(WIDTH) alunit(Unpipelined_CPU_src_a_a6, Unpipelined_CPU_src_b_a6, Unpipelined_CPU_alu_control_a6, Unpipelined_CPU_alu_out_a6[WIDTH-1:0], Unpipelined_CPU_zero_a6);
         </span><span class="tlx_comments">//_@7
            //*memwrite = *reset ? 1'b0 // avoid writing 'X
            //                   : $valid_instr &amp;&amp; $sb_type;
         //_@6
            //*writedata = $rd2;
      
      
   //_&gt;pipelined
         
      //_|cpu
         //_@0
            </span><span class="tlx_logic">assign Pipelined_CPU_reset_a0 = reset;
            
            </span><span class="tlx_comments">// Ready for next instruction?
            </span><span class="tlx_logic">assign Pipelined_CPU_valid_instr_a0 = !Pipelined_CPU_reset_a0 &amp;&amp;
                           (Pipelined_CPU_reset_a1 ||   </span><span class="tlx_comments">// Valid immediately after reset
                            </span><span class="tlx_logic">(Pipelined_CPU_beq_type_a6 || Pipelined_CPU_jtype_a6) ||  </span><span class="tlx_comments">// Branch &amp; jump
                            </span><span class="tlx_logic">(Pipelined_CPU_sb_type_a7 || Pipelined_CPU_rtype_a7) ||   </span><span class="tlx_comments">// Store &amp; arith
                            </span><span class="tlx_logic">Pipelined_CPU_lb_type_a8                     </span><span class="tlx_comments">// Load
                           </span><span class="tlx_logic">);
         </span><span class="tlx_comments">//_@1  // Fetch PC byte
            </span><span class="tlx_logic">assign Pipelined_CPU_fetch_a1 = Pipelined_CPU_valid_instr_a1 || Pipelined_CPU_valid_instr_a2 || Pipelined_CPU_valid_instr_a3 || Pipelined_CPU_valid_instr_a4;

            </span><span class="tlx_comments">// Memory read/write.
            </span><span class="tlx_logic">assign adr = Pipelined_CPU_mem_type_a7 ? Pipelined_CPU_alu_out_a7 : Pipelined_CPU_Pc_a1;
            assign Pipelined_CPU_mem_read_a1 = Pipelined_CPU_fetch_a1 || Pipelined_CPU_lb_type_a7;
            assign memread = Pipelined_CPU_mem_read_a1;
            </span><span class="tlx_comments">//_?$mem_read
               </span><span class="tlx_logic">assign w_Pipelined_CPU_memdata_a1[WIDTH-1:0] = memdata;

            </span><span class="tlx_comments">// Next PC
            </span><span class="tlx_logic">assign Pipelined_CPU_Pc_a0[WIDTH-1:0] = Pipelined_CPU_reset_a1                       ? '0          :
                                  Pipelined_CPU_fetch_a1                       ? Pipelined_CPU_alu_out_a6 :
                                  Pipelined_CPU_jtype_a6                    ? Pipelined_CPU_imm_x4_a6  :
                                  Pipelined_CPU_beq_update_pc_a7            ? Pipelined_CPU_alu_out_a7 :
                                  Pipelined_CPU_Pc_a1[WIDTH-1:0];
         </span><span class="tlx_comments">//_@4
            // Combine instruction bytes.
            //_?$valid_instr
               </span><span class="tlx_logic">assign w_Pipelined_CPU_instr_a4[31:0] = {Pipelined_CPU_memdata_a1, Pipelined_CPU_memdata_a2, Pipelined_CPU_memdata_a3, Pipelined_CPU_memdata_a4} `BOGUS_USE(Pipelined_CPU_instr_a5[31:0]);  </span><span class="tlx_comments">// BUG WORKAROUND (fixed, but not in EP)!!!!
         
         // decode/reg fetch
         //_@5
            // Characterize the transaction
            
            //_?$valid_instr
               // Instruction fields:
               </span><span class="tlx_logic">assign w_Pipelined_CPU_imm_a5[7:0] = Pipelined_CPU_instr_a5[7:0];
               assign w_Pipelined_CPU_imm_x4_a5[7:0] = {Pipelined_CPU_instr_a5[5:0], 2'b00};
               assign w_Pipelined_CPU_op_a5[5:0] = Pipelined_CPU_instr_a5[31:26];
               assign w_Pipelined_CPU_funct_a5[5:0] = Pipelined_CPU_instr_a5[5:0];
            
            </span><span class="tlx_comments">// Operand decode:
            </span><span class="tlx_logic">assign Pipelined_CPU_rtype_a5    = Pipelined_CPU_valid_instr_a5 &amp;&amp; (Pipelined_CPU_op_a5 == 6'b000000);
            assign Pipelined_CPU_mem_type_a5 = Pipelined_CPU_valid_instr_a5 &amp;&amp;  Pipelined_CPU_op_a5[5];
            assign Pipelined_CPU_lb_type_a5  = Pipelined_CPU_mem_type_a5 &amp;&amp; !Pipelined_CPU_op_a5[3];
            assign Pipelined_CPU_sb_type_a5  = Pipelined_CPU_mem_type_a5 &amp;&amp;  Pipelined_CPU_op_a5[3];
            assign Pipelined_CPU_beq_type_a5 = Pipelined_CPU_valid_instr_a5 &amp;&amp; Pipelined_CPU_op_a5[2];
            assign Pipelined_CPU_jtype_a5    = Pipelined_CPU_valid_instr_a5 &amp;&amp; Pipelined_CPU_op_a5[1];

         </span><span class="tlx_comments">//_@6
            // The pipeline is utilized the cycle before a beq.
            </span><span class="tlx_logic">assign Pipelined_CPU_beq_target_calc_a6 = Pipelined_CPU_valid_instr_a5 &amp;&amp; Pipelined_CPU_beq_type_a5;
         </span><span class="tlx_comments">//_@7
            </span><span class="tlx_logic">assign Pipelined_CPU_beq_update_pc_a7 = Pipelined_CPU_beq_target_calc_a7 &amp;&amp; Pipelined_CPU_zero_a6;

         </span><span class="tlx_comments">//_@5
            // Register access:
            </span><span class="tlx_logic">assign Pipelined_CPU_ra1_a5[REGBITS-1:0] = Pipelined_CPU_instr_a5[REGBITS+20:21];
            assign Pipelined_CPU_ra2_a5[REGBITS-1:0] = Pipelined_CPU_instr_a5[REGBITS+15:16];
            </span><span class="tlx_comments">//_?$regwrite
               </span><span class="tlx_logic">assign w_Pipelined_CPU_wa_a5[REGBITS-1:0] = Pipelined_CPU_rtype_a7
                       ? Pipelined_CPU_instr_a7[REGBITS+10:11]   </span><span class="tlx_comments">// %+2
                       </span><span class="tlx_logic">: Pipelined_CPU_instr_a8[REGBITS+15:16];
               assign w_Pipelined_CPU_wd_a5[WIDTH-1:0] = Pipelined_CPU_rtype_a7 ? Pipelined_CPU_alu_out_a7 : Pipelined_CPU_memdata_a2;
            assign Pipelined_CPU_regwrite_a5 = Pipelined_CPU_lb_type_a8 || Pipelined_CPU_rtype_a7;
            regfile #(WIDTH,REGBITS) rf2(clk, Pipelined_CPU_regwrite_a5, Pipelined_CPU_ra1_a5, Pipelined_CPU_ra2_a5,
                                        Pipelined_CPU_wa_a5, Pipelined_CPU_wd_a5, Pipelined_CPU_rd1_a5[WIDTH-1:0], Pipelined_CPU_rd2_a5[WIDTH-1:0]);

         </span><span class="tlx_comments">// ALU ($src_a, $src_b) -&gt; ($alu_rslt, $zero)
         //
            
         // ALU sources
         //_@6
            </span><span class="tlx_logic">assign Pipelined_CPU_alu_valid_a6 = Pipelined_CPU_valid_instr_a6 ||    </span><span class="tlx_comments">// any instr
                         </span><span class="tlx_logic">Pipelined_CPU_beq_type_a5 ||  </span><span class="tlx_comments">// branch target
                         </span><span class="tlx_logic">Pipelined_CPU_fetch_a1;         </span><span class="tlx_comments">// next PC byte
            //_?$alu_valid
               </span><span class="tlx_logic">assign w_Pipelined_CPU_src_a_a6[WIDTH-1:0] = Pipelined_CPU_valid_instr_a6 ? Pipelined_CPU_rd1_a6 : Pipelined_CPU_Pc_a1;
               assign w_Pipelined_CPU_src_b_a6[WIDTH-1:0] = 
                   Pipelined_CPU_fetch_a1                         ? 1       :       </span><span class="tlx_comments">// Next byte of instr
                   </span><span class="tlx_logic">Pipelined_CPU_beq_target_calc_a6                  ? Pipelined_CPU_imm_x4_a5 :  </span><span class="tlx_comments">// Branch target
                   </span><span class="tlx_logic">Pipelined_CPU_mem_type_a6                         ? Pipelined_CPU_imm_a6 :          </span><span class="tlx_comments">// Mem addr calc
                                                       </span><span class="tlx_logic">Pipelined_CPU_rd2_a6;           </span><span class="tlx_comments">// ALU instr
            
               </span><span class="tlx_logic">assign w_Pipelined_CPU_alu_op_a6[1:0] = Pipelined_CPU_valid_instr_a6 ? {Pipelined_CPU_rtype_a6, Pipelined_CPU_beq_type_a6} : 2'b00;
               aludec ac2(Pipelined_CPU_alu_op_a6, Pipelined_CPU_funct_a6, w_Pipelined_CPU_alu_control_a6[2:0]);
            
               </span><span class="tlx_comments">// ALU
               </span><span class="tlx_logic">alu #(WIDTH) alunit2(Pipelined_CPU_src_a_a6, Pipelined_CPU_src_b_a6, Pipelined_CPU_alu_control_a6, w_Pipelined_CPU_alu_out_a6[WIDTH-1:0], w_Pipelined_CPU_zero_a6);
            
         </span><span class="tlx_comments">//_@7
            </span><span class="tlx_logic">assign memwrite = reset ? 1'b0 </span><span class="tlx_comments">// avoid writing 'X
                               </span><span class="tlx_logic">: Pipelined_CPU_sb_type_a7;
            </span><span class="tlx_comments">//_?$sb_type
               </span><span class="tlx_logic">assign writedata = Pipelined_CPU_rd2_a7;


</span><span class="tlx_comments">//_\SV
</span><span class="tlx_untouched">endmodule




</span><span class="tlx_comments">// And this will all go away:

// simplified MIPS processor
</span><span class="tlx_untouched">module mips #(parameter WIDTH = 8, REGBITS = 3)
             (input  logic             clk, pre_reset, 
              input  logic [WIDTH-1:0] memdata, 
              output logic             memread, memwrite, 
              output logic [WIDTH-1:0] adr, writedata);

   logic [31:0] instr;
   logic        zero, alusrca, memtoreg, iord, pcen, regwrite, regdst;
   logic [1:0]  pcsrc, alusrcb;
   logic [3:0]  irwrite;
   logic [2:0]  alucontrol;
   logic [5:0]  op, funct;
   logic reset;

   flop #(1) rst_flp(clk, pre_reset, reset);
   

   assign op = instr[31:26];      
   assign funct = instr[5:0];  
      
   controller  cont(clk, reset, op, funct, zero, memread, memwrite, 
                    alusrca, memtoreg, iord, pcen, regwrite, regdst,
                    pcsrc, alusrcb, alucontrol, irwrite);
   datapath    #(WIDTH, REGBITS) 
               dp(clk, reset, memdata, alusrca, memtoreg, iord, pcen,
                  regwrite, regdst, pcsrc, alusrcb, irwrite, alucontrol,
                  zero, instr, adr, writedata);
endmodule

module controller(input logic clk, reset, 
                  input  logic [5:0] op, funct,
                  input  logic       zero, 
                  output logic       memread, memwrite, alusrca,  
                  output logic       memtoreg, iord, pcen, 
                  output logic       regwrite, regdst, 
                  output logic [1:0] pcsrc, alusrcb,
                  output logic [2:0] alucontrol,
                  output logic [3:0] irwrite);

  statetype       state;
  logic           pcwrite, branch;
  logic     [1:0] aluop;

  </span><span class="tlx_comments">// control FSM
  </span><span class="tlx_untouched">statelogic statelog(clk, reset, op, state);
  outputlogic outputlog(state, memread, memwrite, alusrca,
                        memtoreg, iord, 
                        regwrite, regdst, pcsrc, alusrcb, irwrite, 
                        pcwrite, branch, aluop);

  </span><span class="tlx_comments">// other control decoding
  </span><span class="tlx_untouched">aludec  ac(aluop, funct, alucontrol);
  assign pcen = pcwrite | (branch &amp; zero); </span><span class="tlx_comments">// program counter enable
</span><span class="tlx_untouched">endmodule

module statelogic(input  logic       clk, reset,
                  input  logic [5:0] op,
                  output statetype   state);

  statetype nextstate;
  
  always_ff @(posedge clk)
    if (reset) state &lt;= FETCH1;
    else       state &lt;= nextstate;
    
  always_comb
    begin
      case (state)
        FETCH1:  nextstate = FETCH2;
        FETCH2:  nextstate = FETCH3;
        FETCH3:  nextstate = FETCH4;
        FETCH4:  nextstate = DECODE;
        DECODE:  case(op)
                   LB:      nextstate = MEMADR;
                   SB:      nextstate = MEMADR;
                   RTYPE:   nextstate = RTYPEEX;
                   BEQ:     nextstate = BEQEX;
                   J:       nextstate = JEX;
                   default: nextstate = FETCH1; </span><span class="tlx_comments">// should never happen
                 </span><span class="tlx_untouched">endcase
        MEMADR:  case(op)
                   LB:      nextstate = LBRD;
                   SB:      nextstate = SBWR;
                   default: nextstate = FETCH1; </span><span class="tlx_comments">// should never happen
                 </span><span class="tlx_untouched">endcase
        LBRD:    nextstate = LBWR;
        LBWR:    nextstate = FETCH1;
        SBWR:    nextstate = FETCH1;
        RTYPEEX: nextstate = RTYPEWR;
        RTYPEWR: nextstate = FETCH1;
        BEQEX:   nextstate = FETCH1;
        JEX:     nextstate = FETCH1;
        default: nextstate = FETCH1; </span><span class="tlx_comments">// should never happen
      </span><span class="tlx_untouched">endcase
    end
endmodule

module outputlogic(input statetype state,
                   output logic       memread, memwrite, alusrca,  
                   output logic       memtoreg, iord, 
                   output logic       regwrite, regdst, 
                   output logic [1:0] pcsrc, alusrcb,
                   output logic [3:0] irwrite,
                   output logic       pcwrite, branch,
                   output logic [1:0] aluop);

  always_comb
    begin
      </span><span class="tlx_comments">// set all outputs to zero, then 
      // conditionally assert just the appropriate ones
      </span><span class="tlx_untouched">irwrite = 4'b0000;
      pcwrite = 0; branch = 0;
      regwrite = 0; regdst = 0;
      memread = 0; memwrite = 0;
      alusrca = 0; alusrcb = 2'b00; aluop = 2'b00;
      pcsrc = 2'b00;
      iord = 0; memtoreg = 0;
      case (state)
        FETCH1: 
          begin
            memread = 1; 
            irwrite = 4'b0001; 
            alusrcb = 2'b01; 
            pcwrite = 1;
          end
        FETCH2: 
          begin
            memread = 1;
            irwrite = 4'b0010;
            alusrcb = 2'b01;
            pcwrite = 1;
          end
        FETCH3:
          begin
            memread = 1;
            irwrite = 4'b0100;
            alusrcb = 2'b01;
            pcwrite = 1;
          end
        FETCH4:
          begin
            memread = 1;
            irwrite = 4'b1000;
            alusrcb = 2'b01;
            pcwrite = 1;
          end
        DECODE: alusrcb = 2'b11;
        MEMADR:
          begin
            alusrca = 1;
            alusrcb = 2'b10;
          end
        LBRD:
          begin
            memread = 1;
            iord    = 1;
          end
        LBWR:
          begin
            regwrite = 1;
            memtoreg = 1;
          end
        SBWR:
          begin
            memwrite = 1;
            iord     = 1;
          end
        RTYPEEX: 
          begin
            alusrca = 1;
            aluop   = 2'b10;
          end
        RTYPEWR:
          begin
            regdst   = 1;
            regwrite = 1;
          end
        BEQEX:
          begin
            alusrca = 1;
            aluop   = 2'b01;
            branch  = 1;
            pcsrc   = 2'b01;
          end
        JEX:
          begin
            pcwrite  = 1;
            pcsrc    = 2'b10;
          end
      endcase
    end
endmodule

module aludec(input  logic [1:0] aluop, 
              input  logic [5:0] funct, 
              output logic [2:0] alucontrol);

  always_comb
    case (aluop)
      2'b00: alucontrol = 3'b010;  </span><span class="tlx_comments">// add for lb/sb/addi
      </span><span class="tlx_untouched">2'b01: alucontrol = 3'b110;  </span><span class="tlx_comments">// subtract (for beq)
      </span><span class="tlx_untouched">default: case(funct)      </span><span class="tlx_comments">// R-Type instructions
                 </span><span class="tlx_untouched">ADD: alucontrol = 3'b010;
                 SUB: alucontrol = 3'b110;
                 AND: alucontrol = 3'b000;
                 OR:  alucontrol = 3'b001;
                 SLT: alucontrol = 3'b111;
                 default:   alucontrol = 3'b101; </span><span class="tlx_comments">// should never happen
               </span><span class="tlx_untouched">endcase
    endcase
endmodule

module datapath #(parameter WIDTH = 8, REGBITS = 3)
                 (input  logic             clk, reset, 
                  input  logic [WIDTH-1:0] memdata, 
                  input  logic             alusrca, memtoreg, iord, 
                  input  logic             pcen, regwrite, regdst,
                  input  logic [1:0]       pcsrc, alusrcb, 
                  input  logic [3:0]       irwrite, 
                  input  logic [2:0]       alucontrol, 
                  output logic             zero, 
                  output logic [31:0]      instr, 
                  output logic [WIDTH-1:0] adr, writedata);

  logic [REGBITS-1:0] ra1, ra2, wa;
  logic [WIDTH-1:0]   pc, nextpc, data, rd1, rd2, wd, a, srca, 
                      srcb, aluresult, aluout, immx4;

  logic [WIDTH-1:0] CONST_ZERO = 0;
  logic [WIDTH-1:0] CONST_ONE =  1;

  </span><span class="tlx_comments">// shift left immediate field by 2
  </span><span class="tlx_untouched">assign immx4 = {instr[WIDTH-3:0],2'b00};

  </span><span class="tlx_comments">// register file address fields
  </span><span class="tlx_untouched">assign ra1 = instr[REGBITS+20:21];
  assign ra2 = instr[REGBITS+15:16];
  mux2       #(REGBITS) regmux(instr[REGBITS+15:16], 
                               instr[REGBITS+10:11], regdst, wa);

   </span><span class="tlx_comments">// independent of bit width, load instruction into four 8-bit registers over four cycles
  </span><span class="tlx_untouched">flopen     #(8)      ir0(clk, irwrite[0], memdata[7:0], instr[7:0]);
  flopen     #(8)      ir1(clk, irwrite[1], memdata[7:0], instr[15:8]);
  flopen     #(8)      ir2(clk, irwrite[2], memdata[7:0], instr[23:16]);
  flopen     #(8)      ir3(clk, irwrite[3], memdata[7:0], instr[31:24]);

  </span><span class="tlx_comments">// datapath
  </span><span class="tlx_untouched">flopenr    #(WIDTH)  pcreg(clk, reset, pcen, nextpc, pc);
  flop       #(WIDTH)  datareg(clk, memdata, data);
  flop       #(WIDTH)  areg(clk, rd1, a);
  flop       #(WIDTH)  wrdreg(clk, rd2, writedata);
  flop       #(WIDTH)  resreg(clk, aluresult, aluout);
  mux2       #(WIDTH)  adrmux(pc, aluout, iord, adr);
  mux2       #(WIDTH)  src1mux(pc, a, alusrca, srca);
  mux4       #(WIDTH)  src2mux(writedata, CONST_ONE, instr[WIDTH-1:0], 
                               immx4, alusrcb, srcb);
  mux3       #(WIDTH)  pcmux(aluresult, aluout, immx4, 
                             pcsrc, nextpc);
  mux2       #(WIDTH)  wdmux(aluout, data, memtoreg, wd);
  regfile    #(WIDTH,REGBITS) rf(clk, regwrite, ra1, ra2, 
                                 wa, wd, rd1, rd2);
  alu        #(WIDTH) alunit(srca, srcb, alucontrol, aluresult, zero);
endmodule

module alu #(parameter WIDTH = 8)
            (input  logic [WIDTH-1:0] a, b, 
             input  logic [2:0]       alucontrol, 
             output logic [WIDTH-1:0] result,
             output logic             zero);

  logic [WIDTH-1:0] b2, andresult, orresult, sumresult, sltresult;

  andN    andblock(a, b, andresult);
  orN     orblock(a, b, orresult);
  condinv binv(b, alucontrol[2], b2);
  adder   addblock(a, b2, alucontrol[2], sumresult);
  </span><span class="tlx_comments">// slt should be 1 if most significant bit of sum is 1
  </span><span class="tlx_untouched">assign sltresult = sumresult[WIDTH-1];

  mux4 resultmux(andresult, orresult, sumresult, sltresult, alucontrol[1:0], result);
  zerodetect #(WIDTH) zd(result, zero);
endmodule

module regfile #(parameter WIDTH = 8, REGBITS = 3)
                (input  logic               clk, 
                 input  logic               regwrite, 
                 input  logic [REGBITS-1:0] ra1, ra2, wa, 
                 input  logic [WIDTH-1:0]   wd, 
                 output logic [WIDTH-1:0]   rd1, rd2);

   logic [WIDTH-1:0] RAM [2**REGBITS-1:0];

  </span><span class="tlx_comments">// three ported register file
  // read two ports combinationally
  // write third port on rising edge of clock
  // register 0 hardwired to 0
  </span><span class="tlx_untouched">always @(posedge clk)
    if (regwrite) RAM[wa] &lt;= wd;

  assign rd1 = ra1 ? RAM[ra1] : 0;
  assign rd2 = ra2 ? RAM[ra2] : 0;
endmodule

module zerodetect #(parameter WIDTH = 8)
                   (input  logic [WIDTH-1:0] a, 
                    output logic             y);

   assign y = (a==0);
endmodule	

module flop #(parameter WIDTH = 8)
             (input  logic             clk, 
              input  logic [WIDTH-1:0] d, 
              output logic [WIDTH-1:0] q);

  always_ff @(posedge clk)
    q &lt;= d;
endmodule

module flopen #(parameter WIDTH = 8)
               (input  logic             clk, en,
                input  logic [WIDTH-1:0] d, 
                output logic [WIDTH-1:0] q);

  always_ff @(posedge clk)
    if (en) q &lt;= d;
endmodule

module flopenr #(parameter WIDTH = 8)
                (input  logic             clk, reset, en,
                 input  logic [WIDTH-1:0] d, 
                 output logic [WIDTH-1:0] q);
 
  always_ff @(posedge clk)
    if      (reset) q &lt;= 0;
    else if (en)    q &lt;= d;
endmodule

module mux2 #(parameter WIDTH = 8)
             (input  logic [WIDTH-1:0] d0, d1, 
              input  logic             s, 
              output logic [WIDTH-1:0] y);

  assign y = s ? d1 : d0; 
endmodule

module mux3 #(parameter WIDTH = 8)
             (input  logic [WIDTH-1:0] d0, d1, d2,
              input  logic [1:0]       s, 
              output logic [WIDTH-1:0] y);

  always_comb 
    casez (s)
      2'b00: y = d0;
      2'b01: y = d1;
      2'b1?: y = d2;
    endcase
endmodule

module mux4 #(parameter WIDTH = 8)
             (input  logic [WIDTH-1:0] d0, d1, d2, d3,
              input  logic [1:0]       s, 
              output logic [WIDTH-1:0] y);

  always_comb
    case (s)
      2'b00: y = d0;
      2'b01: y = d1;
      2'b10: y = d2;
      2'b11: y = d3;
    endcase
endmodule

module andN #(parameter WIDTH = 8)
             (input  logic [WIDTH-1:0] a, b,
              output logic [WIDTH-1:0] y);

  assign y = a &amp; b;
endmodule

module orN #(parameter WIDTH = 8)
            (input  logic [WIDTH-1:0] a, b,
             output logic [WIDTH-1:0] y);

  assign y = a | b;
endmodule

module inv #(parameter WIDTH = 8)
            (input  logic [WIDTH-1:0] a,
             output logic [WIDTH-1:0] y);

  assign y = ~a;
endmodule

module condinv #(parameter WIDTH = 8)
                (input  logic [WIDTH-1:0] a,
                 input  logic             invert,
                 output logic [WIDTH-1:0] y);

  logic [WIDTH-1:0] ab;

  inv  inverter(a, ab);
  mux2 invmux(a, ab, invert, y);
endmodule

module adder #(parameter WIDTH = 8)
              (input  logic [WIDTH-1:0] a, b,
               input  logic             cin,
               output logic [WIDTH-1:0] y);

  assign y = a + b + cin;
endmodule


</span><span class="tlx_comments">// Undefine macros defined by SandPiper (in &quot;design_gen.sv&quot;).
</span><span class="tlx_structure">`undef BOGUS_USE
`undef WHEN
</span>
</pre>
        </div>
    </div>
    <canvas id="overlay" width="280" height="200">
    </canvas>
    <svg id="sp_svg" x="429" y="430" width="112" height="40">
      <rect id="sp_rect" x="2" y="2" width="108" height="36" rx="10" ry="10" />
      <text id="sp_text" x="7" y="25" textLength="98">SandPiper</text>
    </svg>

</body>
</html>

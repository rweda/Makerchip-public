M5 Text Processing Language User’s
Guide
To enrich any text format
M5 version 1.0, document subversion 1, 2023
by Steve Hoover, Redwood EDA, LLC
(steve.hoover@redwoodeda.com)
This document is licensed under the CC0 1.0 Universal license.
The M5 macro preprocessor enhances the Gnu M4 macro preprocessor, adding features typical of
programming languages.

Table of Contents
1. Background Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1. Overview. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2. About this Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3. M5’s Place in the World . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.1. M5’s Association with TL-Verilog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.2. M5 Versus M4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.3. M5 Above and Beyond M4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.4. Limitations of M5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.4. M5 Status. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2. Getting Started with the M5 Tool . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.1. Configuring M5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.2. Running M5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.3. Ensure No Impact . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
3. An Overview of M5 Concepts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3.1. Macro Preprocessing in General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3.2. Macros Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3.3. Quotes Overview. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
3.4. Variables Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
3.5. Macro Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.6. Code Syntax Overview. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.7. Functions and Scope Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.8. Function Output Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.9. Libraries and Namespaces Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.10. Processing Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4. Sugar-Free M5 Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

1

4.1. Defining Sugar-free . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4.2. Quotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4.3. Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
4.4. Declaring Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
4.5. Calling Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
4.6. Macro Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
5. Syntactic Sugar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
5.1. Comments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
5.1.1. M5 Comments (/// and /**…**/) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
5.1.2. Target-Language Comments (E.g. //) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
5.1.3. Statement Comments (E.g. /) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
5.2. Macro Call Sugar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
5.3. Variable Sugar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
5.4. Backslash Word Boundary (m5_\ and \m5_). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
5.5. Multi-line Constructs: Blocks and Bodies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
5.5.1. What are Bodies and Blocks? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
5.5.2. Macro Bodies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
5.5.3. Code Blocks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
5.5.4. Scoped Code Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
5.5.5. Text Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
5.5.6. Evaluate Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
5.5.7. Block Labels: Escaping Blocks and Labeled Numbered Parameters . . . . . . . . . . . . . . . . . . . 20
5.6. Syntax Checks and Pragmas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
5.6.1. Indentation Checks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
5.6.2. Quote and Parenthesis Matching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
5.6.3. Pragmas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
6. Coding Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
6.1. Coding Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
6.2. Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
6.3. Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
6.3.1. Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
6.3.2. When To Use What Type of Parameter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
6.3.3. Function Call Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
6.3.4. Function Arguments Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
6.3.5. Aftermath . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
6.3.6. Passing Arguments by Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
6.3.7. Returning Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
6.3.8. Functions with Body Arguments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
6.3.9. Tail Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
6.4. Coding Paradigms, Patterns, Tips, Tricks, and Gotchas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
6.4.1. Variable Masking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

2

7. Macro Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
7.1. Specification Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
7.2. Assigning and Accessing Macros/Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
7.2.1. Declaring/Setting Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
7.2.2. Declaring Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
7.2.3. Accessing Macro/Variable Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
7.3. Code Constructs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
7.3.1. Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
7.3.2. Conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
7.3.3. Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
7.3.4. Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
7.4. Working with Strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
7.4.1. Special Characters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
7.4.2. Slicing and Dicing Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
7.4.3. Formatting Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
7.4.4. Inspecting Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
7.4.5. Safely Working with Strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
7.4.6. Regular Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
7.5. Utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
7.5.1. Fundamental Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
7.5.2. Manipulating Macro Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
7.5.3. Argument Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
7.5.4. Arithmetic Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
7.5.5. Boolean Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
7.5.6. Within Functions or Code Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
7.6. Checking and Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
7.6.1. Checking and Reporting to STDERR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
7.6.2. Uncategorized Debug Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
8. Reference Card . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

1. Background Information
1.1. Overview
M5 is a macro preprocessor on steroids. It is built on the simple principle of text substitution but
provides features and syntax on par with other simple programming languages. It is an easy and
capable tack-on to any text format as well as a reasonable general-purpose programming language
specializing in text processing. Its broad applicability makes M5 a valuable tool in every
programmer/engineer/scientist/AI’s toolbelt.
M5 was developed by Redwood EDA, LLC and is used in conjunction with TL-Verilog, but it is
3

appropriate as an advance macro preprocessor or code generator for any target language or even
as a stand-alone language. M5 is constructed with a bit of pre-preprocessing, providing syntactic
sugar, and then the use of the Gnu M4 macro preprocessor with an extensive library.
This chapter provides background and general information about M5, guidance about this
specification, and instructions for using M5.

1.2. About this Specification
This document is intended to stand on its own, independent of the M4 documentation. The M4
documentation can, in fact, be confusing as M5 has philosophical differences. Differences versus
M4 are described in M5 Versus M4.

1.3. M5’s Place in the World
This section describes the history of and motivation for M5 and it’s relation to M4 and TL-Verilog.

1.3.1. M5’s Association with TL-Verilog
Although M5 was developed for TL-Verilog, it is not specifically tied to TL-Verilog. It does, however,
like all M4 libraries, depend upon a specific set of M4 syntax configurations, and these
configurations were chosen to best suit TL-Verilog.
The required M4 configurations are described in Getting Started with the M5 Tool. These
configurations establish:
• builtin macro prefix: m4_ (used by the M5 library, not by the end user)
• quote characters: [' and ']
TL-Verilog supports other TL-Verilog-specific macro preprocessing. Documentation can be found
within the Makerchip IDE.

1.3.2. M5 Versus M4
M5 uses M4 to implement a macro-preprocessing language with some subtle philosophical
differences. While M4 is adequate for simple substitutions, M5 aims to preserve the conceptual
simplicity of macro preprocessing while adding features that improve readability and
manageability of more complex use cases.
M4 favors aggressive macro expansion, which frequently leads to the need for multiple levels of
nested quoting to prevent unintended substitutions. This leads to obscure bugs. M5 implicitly
quotes arguments and returned text, favoring explicit expansion.

1.3.3. M5 Above and Beyond M4
M5 contributes:
• features that feel like a typical, simple programming language

4

• literal string variables
• functions with explicit named arguments
• scope for variable declarations
• an intentionally minimal amount of syntactic sugar
• document generation assistance
• debug aids such as stack traces
• safer parsing and string manipulation
• a richer core library of utilities
• a future plan for modular libraries

1.3.4. Limitations of M5
M4 has certain limitations that M5 is unable to address. M5 uses M4 as is without modifications to
the M4 implementation (though these limitations may motivate changes to M4 in the future).
1.3.4.1. Modularity
M4 does not provide any library, namespace, and version management facilities. Though M5 does
not currently address these needs, plans have been sketched in code comments.
1.3.4.2. String processing
While macro processing is all about string processing, safely manipulating arbitrary strings is not
possible in M4 or it is beyond awkward at best. M4 provides m4_regexp, m4_patsubst, and m4_substr.
These return unquoted strings that will necessarily be elaborated, potentially altering the string.
While M5 is able to jump through hoops to provide m5_regex and m5_substr (for strings of limited
length) that return quoted (literal) text, m4_patsubst cannot be fixed (though m5_for_each_regex is
similar). The result of m4_patsubst can be quoted only by quoting the input string, which can
complicate the match expression, or by ensuring that all text is matched, which can be awkward,
and quoting substitutions.
In addition to these issues, care must be taken to ensure that resulting text does not contain
mismatching quotes or parentheses or combine with surrounding text to result in the same. Such
resulting mismatches are difficult to debug. M5 provides a notion of "unquoted strings" that can be
safely manipulated using m5_regex, and m5_substr.
Additionally the regex configuration used by M4 is quite dated. For example, it does not support
lookahead, lazy matches, and character codes.
1.3.4.3. Instrospection
Introspection is essentially impossible. The only way to see what is defined is to dump definitions to
a file and parse this file.

5

1.3.4.4. Recursion
Recursion has a fixed (command-line) depth limit, and this limit is not applied reliably.
1.3.4.5. Unicode
M4 is an old tool and was built for ASCII text. UTF-8 is now the most common text format. It is a
superset of ASCII that encodes additional characters as two or more bytes using byte codes (0x100xFF) that do not conflict by those defined by ASCII (0x00-0x7F). All such bytes (0x10-0xFF) are
treated as characters by M4 with no special meaning, so these characters pass through, unaffected,
in macro processing like most others. There are two implications to be aware of. First, m5_length
provides a length in bytes, not characters. Second, m5_substr and regular expressions manipulate
bytes, not characters. This can result in text being split in the mid-character, resulting in invalid
character encodings.
1.3.4.6. Debugging features
M4’s facilities for associating output with input only map output lines to line numbers of top-level
calls. M4 does not maintain a call stack with line numbers.
M4 and M5 have no debugger to step through code. Printing (see m5_DEBUG is the debugging
mechanism of choice.

1.4. M5 Status
Certain features documented herein, specifically Syntactic Sugar, currently work only in
conjunction with the TL-Verilog macro preprocessor. The intent is to support them in M5 itself, and
they are documented with that in mind.

2. Getting Started with the M5 Tool
2.1. Configuring M5
M5 adds a minimal amount of syntax, and it is important that this syntax is unlikely to conflict with
the target language syntax. The syntax that could conflict is listed in Ensure No Impact. Currently,
there is no easy mechanisms to configure this syntax.

2.2. Running M5
Currently, M5 is bundled to run with TL-Verilog tool flows. The script that builds this
documentation can be consulted for example usage by way of TL-Verilog tool flows.

2.3. Ensure No Impact
When enabling the use of M5 on a file, first, be sure M5 processing does nothing to the file. As used
for TL-Verilog, M5 should output the input text, unaltered, as long as your file contains no:

6

• quotes, e.g. [', '])
• m5_ or m4_
• M5 comments, e.g. ///, /, /
• (and specific to TL-Verilog: \TLV)
• (mismatched parentheses may result in warnings)
In other configurations, the following may also result in processing:
• code blocks, e.g. [ or { followed by a newline or ] or } beginning a line after optional whitespace

3. An Overview of M5 Concepts
3.1. Macro Preprocessing in General
Macro preprocessors extend a target programming language, text format, or any arbitrary text with
the ability to define and call (aka instantiate, invoke, expand, evaluate, or elaborate) parameterized
macros that provide text substitutions. Macros are generally used to provide convenient shorthand
for commonly-used constructs. Macro preprocessors processes a text file sequentially with a default
behavior of passing the input text through as output text. When a macro name is encountered, it
and its argument list are substituted for new text according to its definition.
M5 provides convenient syntax for macro preprocessing as well as programatic text processing,
sharing the same macros for each. This provides advanced text manipulation to supercharge any
language or text format, or it can be used to fully process any text format.

3.2. Macros Overview
In source context, a macro that simply outputs a static text string can be defined like this:

m5_macro(hello, Hello World!)
And called like this:

m5_hello()
Resulting in:

Hello World!
Macros can also be parameterized. Here we define a macro that outputs a string with a single
parameter referenced as $1:

7

m5_macro(hello, Hello $1!)
And call it like this:

m5_hello(World)
Resulting in:

Hello World!
For more details on macro syntax, see Declaring Macros, Calling Macros, and Macro Arguments.

3.3. Quotes Overview
Quotes ([' and ']) may be used around text to prevent substitutions. For example, to provide a
macro whose result includes a comma, quotes are needed:

m5_macro(hello, ['Hello, $1!'])
Without these quotes, the comma in Hello, $1! would be interpreted as a macro argument
separator.
Furthermore, a second level of quotes may be needed to prevent the interpretation of the comma
after substitution:

m5_macro(hello, ['['Hello, $1!']'])
m5_hello(World)
The call substitutes with ['Hello, World!'] (actually ['Hello, World!']['']), which elaborates to the
literal text:

Hello, World!
For more details on quote use, see Quotes.

3.4. Variables Overview
Variables hold string values. They can be thought of as macros without arguments. They are
defined as:

8

m5_var(Hello, ['Hello, World!'])
m5_var(Age, 23)
And used as:

m5_Hello I am m5_Age years old.
Resulting in:

Hello, World! I am 23 years old.
Variables are always returned as literal strings, so a second level of quoting is not required for the
definition of Hello.
Variables are scoped, and by convention, scoped definitions are named in camel case (strictly
speaking, Pascal case).
For more details on variable use, see Variables and Variable Sugar.

3.5. Macro Stacks
All macros and variables, are actually stacks of definitions that can be pushed and popped. (These
stacks are frequently one entry deep.) The top definition is active, providing the replacement text
when the macro/variable is instantiated. The others are only accessible by popping the stack.
Pushing and popping are not generally done explicitly, but rather through scoped declarations. See
Scoped Code Blocks.

3.6. Code Syntax Overview
The above syntax is convenient in "source context", embedded into another language. It is clear
where substitutions occur because all macro calls and variables are referenced with an m5_ prefix.
This syntax, however, quickly becomes clunky for any substantial text manipulation, requiring
excessive m5_-prefixing. Additionally, it is difficult to format code readably because carriage returns
and other whitespace are generally taken literally. This results in single-line syntax with many
levels of nesting that quickly become difficult to follow.
Code regions can be defined (using target-language-specific syntax) within which code syntax is
supported.
Take for example this one-line definition in source context of an assert macro:

m5_macro(assert, ['m5_if(['$1'], ['m5_error(['Failed assertion: $1.'])'])'])
In code context, this can be written equivalently (though with a slight performance impact) as:

9

macro(assert, {
if(['$1'], [
error(['Failed assertion: $1.'])
])
})
The m5_ prefix is implied at the beginning of each code "statement".
For more details, see Code Blocks.

3.7. Functions and Scope Overview
M5 also provides a syntax for function declarations with named parameters. The assert macro can
be defined as a function as:

fn(assert, Expr, {
if(m5_Expr, [
error(Failed assertion: m5_Expr.)
])
})
Like any respectable programming language, Expr, above, is local to the function. Functions and
other macros may produce result text (see Function Output Example and Code Blocks). They may
also produce side effects including variable declarations (see Aftermath) and STDERR output (see
m5_error).
For more details on functions, see Functions. For more details on scope, see Scoped Code Blocks.

3.8. Function Output Example
We can add output text to this function indicating assertion failures in the resulting text:

fn(assert, Expr, {
~if(m5_Expr, [
error(Failed assertion: m5_Expr.)
~(Failed assertion: m5_Expr.)
])
})
Statements producing output are prefixed with a tilde (~).

3.9. Libraries and Namespaces Overview
M5 has a simple and effective import mechanism where a macro library file is simply imported by
its URI (URL or local file). Libraries can be imported into their own namespace (though this

10

mechanism is not yet implemented).

3.10. Processing Steps
Several of the above constructs, including code blocks and statements are termed "syntactic sugar"
and are processed in a first pass before macro substitution—yes as a pre-preprocessing step.
M5 processing involves the following (ordered) steps:
• Substitute quotes for single control characters.
• Process syntactic sugar (in a single pass):
◦ Strip M5 comments.
◦ Process other syntactic sugar, including block and label syntax.
◦ Process pragmas; check indentation and quote/parenthesis matching.
• Write the resulting file.
• Run M4 on this file (substituting macros).

4. Sugar-Free M5 Details
4.1. Defining Sugar-free
M5 can be used "sugar-free". It’s just a bit clunky for humans. Syntactic sugar is recognized in the
source file. Text that is constructed on the fly and evaluated (e.g. by m5_eval) is evaluated sugar-free.

4.2. Quotes
Unwanted processing, such as macro substitution, can be avoided using quotes. By default, these
are [' and '] (and a configuration mechanism is not yet available to change this). Like syntactic
sugar, they are recognized only when they appear in a source file and cannot be constructed from
their component characters. Quotes, however, are an essential part of M5, not a syntactic
convenience.
Quoted text begins with ['. The quoted text is parsed only for [' and '] and ends at the
corresponding ']. The quoted text passes through to the resulting text, including internal matching
quotes, without any substitutions. The outer quotes themselves are discarded. The end quote acts as
a word boundary for subsequent text processing.
Within quotes, intervening characters that would otherwise have special treatment, such as
commas, parentheses, and m5_-prefixed words (after sugar processing), have no special treatment.
Quotes can be used to delimit words. For example, the empty quotes below:

Index['']m5_Index

11

enable m5_Index to substitute, as would:

['Index']m5_Index
(Index/m5_Index is a shorthand for this. See Backslash Word Boundary (m5_\ and \m5_).)
Quotes can also be used to avoid the interpretation of m5_foo as syntactic sugar. (See Macro Call
Sugar.)
Special syntax is provided for multi-line literal quoted text. (See Code Blocks.) Outside of those
constructs, quoted text should not contain newlines since newlines are used to format code.
Instead, the m5_nl variable (or macro) provides a literal newline character, for example:

m5_DEBUG(['Line:']m5_nl['

']m5_Line)

4.3. Variables
A variable holds a literal text string. Variables are defined using: m5_var, are reassigned using
m5_set, and are accessed using m5_get. For example:

m5_var(Foo, 5)
m5_set(Foo, m5_calc(m5_Foo + 1))
m5_get(Foo)
Syntactic sugar provides variable access using, e.g., m5_Foo rather than m5_get(Foo). (See Variable
Sugar.)

4.4. Declaring Macros
m5_macro(echo, ['['$1']'])

m5_echo(['Hello, World!'])
substitutes with ['Hello, World!'], and this elaborates as Hello, World!.
The most direct way to declare a macro is with m5_macro. For example:

m5_macro(foo,
['['Args:$1,$2']'])
This defines the macro body as ['Args:$1,$2'].

12

A macro call returns the body of the macro definition with numbered parameters substituted with
the corresponding arguments. Dollar parameter substitutions are made throughout the entire body
string regardless of the use of quotes and adjacent text. The result is then evaluated, so these
macros can perform computations, assign variables, provide argument lists, etc. In this case, the
body is quoted, so its resulting text is literal. For example:

m5_foo(A,B)

==> Yields: "Args:A,B"

A few special dollar parameters are supported in addition to numbered parameters. The following
notations are substituted:
• $1, $2, etc.: These substitute with corresponding arguments.
• $#: The number of arguments.
• $@: This substitutes with a comma delimited list of the arguments, each quoted so as to be taken
literally. So, m5_macro(foo, ['m5_bar($@)']) is one way to define m5_foo(…) to have the same
behavior as m5_bar(…).
• $*: This is rarely useful. It is similar to $@, but arguments are unquoted.
• $0: The name of the macro itself. It can be convenient for making recursive calls (though see
m5_recurse). $0__ can also be used as a name prefix to localize a macro name to this macro,
though this use model is discouraged. (See Variable Masking.) For Functions, $0 is the internal
name holding the function body. It should not be used for recursion but can be used as a unique
prefix.
Macros may be declared by other macros in which case the inner macro body
appears within the outer macro body. Numbered parameters appearing in the
CAUTION

inner body would be substituted as parameters of the outer body. It is generally
not recommended to use numbered parameters for arguments of nested
macros, though it is possible. For more on the topic, see Block Labels: Escaping
Blocks and Labeled Numbered Parameters.

A richer declaration mechanism is provided by m5_fn. (See Functions.)

4.5. Calling Macros
The following illustrates a call of the macro named foo:

m5_foo(hello, 5)

When this syntax appears in a source file, it is recognized as syntatic sugar and is
NOTE

processed to provide additional checking. Here, we specifically descibe the
processing of this syntax when constructed from other processing, noting that
syntactic sugar results in similar behavior. (See. Macro Call Sugar.)

A well-formed M5 macro name is comprised of one or more word characters (a-z, A-Z, 0-9, and _).

13

When elaboration encounters (in unquoted text and without a preceding word character or
immediately following another macro call) m5_, followed immediately by the well-formed name of a
defined macro, followed immediately by ( (e.g. m5_foo() an argument list (see Macro Arguments) is
processed, then the macro is "called" (or "expanded"). $ substitutions are performed on the macro
body (see Declaring Macros), the resulting text replaces the macro name and argument list followed
by an implicit [''] to create a word boundary, and elaboration is resumed from the start of this
substituted text.
Macro names should not be encountered without an argument list. Though this would result in
calling the macro with zero arguments, it is discouraged due to the syntactic confusion with
variables. Macros can be called with zero arguments using m5_call(macro_name) instead. (See
m5_call.)
Though discouraged, it is possible to define macros with names containing nonNOTE

word characters. Such macros can only be called indirectly (e.g. m5_call(b@d, args)).
(See m5_call.)
In addition to m5_ macros, the M4 macros from which M5 is constructed are

NOTE

available, prefixed by m4_, though their direct use is discouraged and this document
does not describe their use. Elaboration of the string m4_ should by avoided.

4.6. Macro Arguments
Macro calls pass arguments within ( and ) that are comma-separated. For each argument,
preceding whitespace is not part of the argument, while postceding whitespace is. Specifically, the
argument list begins after the unquoted (. Subsequent text is elaborated sequentially (invoking
macros and interpreting quotes). The text value of the first argument begins at the first elaborated
non-whitespace charater following the (. Unquoted ( are counted as an argument is processed. An
argument is terminated by the first unquoted and non-parenthetical , or ) in the resulting
elaborated text. A subsequent argument, similarly, begins with the first non-whitespace character
following the , separator. Whitespace includes spaces, newlines, and tabs. An unquoted ) ends the
list.
Some examples to illustrate preceding and postceding whitespace and nested macros:
If, m5_foo(A,B) echoes its arguments to produce literal text {A;B}, then:

m5_foo( A, B)
==> Yields: "{A;B}"
m5_foo(
[''] A,B)
==> Yields: "{ A;B}"
m5_foo( A , B )
==> Yields: "{A ;B }"
m5_foo(m5_foo(A, B), C)
==> Yields: "{{A;B};C}"
m5_foo(m5_foo([')'],B),C)==> Yields: "{{);B};C}" (with a warning about unbalanced
parentheses)
Arguments can be empty text, such as () (one empty argument) and (,) (two empty arguments).
Note that the use of quotes is prefered for clarity. For example, (['']) and ([''], ['']) are
identical to the previous cases.

14

The above syntax does not permit macro calls with zero arguments, but m5_call(macro_name) can be
used for this purpose. (See m5_call.)
Be aware that when argument lists get long, it is useful to break them up on multiple lines. The
newlines should precede, not postcede the arguments, so they are not included in the arguments.
E.g.:

m5_foo(long-arg1,
long-arg2)
Notably, the closing parenthesis should not be on a the next line by itself. This would include the
newline and spaces in the second argument.

5. Syntactic Sugar
5.1. Comments
5.1.1. M5 Comments (/// and /**…**/)
M5 comments are one form of syntactic sugar. They look like:

/// This line comment will disappear.
/** This block comment will also disappear. **/
Block comments begin with /** and end with **/. Line comments begin with /// and end with a
newline. Both are stripped prior to any other processing. As such:
• M5-commented parentheses and quotes are not visible to parenthesis and quote matching
checks, etc.
• M5 comments may follow the [ or { beginning a code block or after a comma and prior to an
argument that begins on the next line without affecting the code block or argument.
Whitespace preceding a line comment is also stripped. Newlines from block comments are
preserved.
Text immediately following **/ may, after stripping the comment, begin the line.
NOTE

Comments are stripped before indentation checking. It is thus generally
recommented that multi-line block comments end with a newline.

In case /// or /** are needed in the resulting file, quotes can be used, e.g.: ['//']['/'], to disrupt
the syntax.

5.1.2. Target-Language Comments (E.g. //)
Comments in the target language are not recognized as comments by M5. To disable M5 code, it is

15

important to use M5 comments, not target-language comments. (Thus it can be especially
problematic when one’s editor mode highlights target-language comments in a manner that
suggests the code has no impact.)

5.1.3. Statement Comments (E.g. /)
These are specific to Code Blocks, introduced later.

5.2. Macro Call Sugar
m5_foo( is syntactic sugar for m5_call(foo,. (See m5_call.) This transformation (as long as it is
evaluated) has no impact other than to verify that the macro exists. m5_foo( should not appear in
literal text that is never to be evaluated as it would get undesirably sugared. (See Quotes and
Backslash Word Boundary (m5_\ and \m5_) for syntax to avoid undesired sugaring.)
NOTE

The M5 processor may avoid applying this sugar for common macros from the M5
core library that are known to exist.

5.3. Variable Sugar
m5_Foo (without a postceding () is syntactic sugar for m5_get(Foo). (See m5_get.) m5_Foo should not
appear in literal text that is never to be evaluated as it would get undesirably sugared. (For syntax
to avoid undesired sugaring, see Quotes and Backslash Word Boundary (m5_\ and \m5_).)

5.4. Backslash Word Boundary (m5_\ and \m5_)
As more convenient alternatives to quotes:
• m5_\foo results in m5_foo without interpretation as syntactic sugar. It should be used in literal
contexts that are not evaluated.
• \m5_foo is shorthand for ['']m5_ to provide a word boundary, enabling M5 processing of m5_foo.

5.5. Multi-line Constructs: Blocks and Bodies
5.5.1. What are Bodies and Blocks?
A "body" is a parameter or macro value that is to be be evaluated in the context of a caller. Macros,
like m5_if and m5_loop have "immediate" body parameters. These bodies are to be evaluated by calls
to these macros themselves. The final argument to a function or macro declaration is an "indirect"
body argument. This body is to be evaluated, not by the declaration macro itself, but by the caller of
the macro it declares.
NOTE

Declaring macros that evaluate body arguments requires special consideration. See
Functions with Body Arguments.

Code Blocks are convenient syntactic sugar constructs for multi-line body arguments formatted like

16

code.
[Text blocks] are syntactic sugar for specifying multi-line blocks of arbitrary text, indented with the
code.

5.5.2. Macro Bodies
A body argument can be provided as a quoted string of text:

m5_if(m5_A > m5_B, ['['Yes, ']m5_A[' > ']m5_B'])
Note that the quoting of ['Yes, '] prevents misinterpretation of the , as an argument separator as
the body is evaluated.
This syntax is fine for simple text substitutions, but it is essentially restricted to a single line which
is unreadable for larger bodies that might define local variables, perform calculations, evaluate
code conditionally, iterate in loops, call other functions, recurse, etc.

5.5.3. Code Blocks
M5 supports special multi-line syntactic sugar convenient for body arguments, called "code blocks".
These look more like blocks of code in a traditional programming language. Aside from comments
and whitespace, they contain only macro calls and variable elaborations ("statements"). The
resulting text of the code block is constructed from the results of these macro calls.
The code below is equivalent to the example above, expressed using a code body (and assuming it is
itself called from within a code body).

/Might result in "Yes, 4 > 2".
~if(m5_A > m5_B, [
~(['Yes, '])
~A
~([' > '])
~B
])
The block begins with [, followed immediately by a newline. It ends with a line that begins with ],
indented consistently with the beginning line. The above code block is "unscoped". A "scoped" code
block uses, instead, { and }. Scopes are detailed in Scoped Code Blocks.
The first non-blank line of the block determines the indentation of the block. Indentation uses
spaces; tabs are discouraged, but must be used consistently if they are used. All non-blank lines at
this level of indentation (after stripping M5 comments) begin a "statement". Lines with deeper
indentation would continue a statement. A continuation line either begins a macro argument or is
part of its own (nested) code block argument.
Essentially, the body, when evaluated, results in the text produced by its statements, which are
macros or variables, listed without their m5_ prefix, or inline text.

17

Specifically, statements can be:
• Macro calls, such as ~if(m5_A > m5_B, …).
• Variable elaborations, such as ~A.
• Output statements, such as ~(['Yes, ']).
• Comments, such as /A comment.
Statements that produce output (as all statements in the above example’s code block do) must be
preceded by ~ (and others may be). This simply helps to identify the source of code block ouput. The
~(…) syntax produces the given text. A m5_ prefix is implicit on statements. In the rare (and
discouraged) event that a macro without this prefix is to be called, such as use of an m4_ macro,
using ~out(m4_…) will do the trick.
The earlier example behaves the same as:

m5_out(m5_if(m5_A > m5_B, m5__block(['
m5_out(['Yes, '])
m5_out(m5_get(A))
m5_out([' > '])
m5_out(m5_get(B))
']))
The (internal) m5__block macro evaluates its argument and results in any text captured by m5_out.
Top-level M5 content (in TL-Verilog, the content of an \m5 region) is formatted as a non-scoped code
block with no output.

5.5.4. Scoped Code Blocks
Scoped Code Blocks are delimited by { / } quotes. Within a code block, variable declarations (e.g.
made by m5_var) are scoped. Their definitions are pushed by the declaration, and popped at the end
of their scope. (See Macro Stacks regarding pushing and popping.)
It is recommended that all indirect body arguments (see Multi-line Constructs: Blocks and Bodies),
such as those of m5_fn be scoped. Immediate body arguments (see Multi-line Constructs: Blocks and
Bodies), such as those of m5_if, are most often unscoped, but scope may be used to isolate the side
effects of the block to explicit m5_out_eval calls. Scoped and unscoped blocks are illustrated in the
following example:

fn(check, Cond, {
if(m5_Cond, [
warning(Check failed.)
])
)}
Declarations from outer scopes are visible in inner scopes. Similarly, declarations from calling
scopes are visible in callee scopes, though functions should generally be written without any

18

assumptions about the calling scope. Exceptions should be clearly documented/commented.
It is fine to redeclare a variable in the same scope. The redeclaration will override
NOTE

the first, and both definitions will be popped after evaluating the code block.
Notably, a variable may be conditionally declared without any negative
consequence on stack maintenance.

By convention, scoped variables and macros use Pascal case, e.g. MyVar. (See [Macro Naming
Conventions].)

5.5.5. Text Blocks
"Text blocks" provide a syntax for multi-line quoted text that is indented with its surroundings.
They are formatted similarly to code blocks, but use standard ([' / '] ) quotes. The openning quote
must be followed by a newline and the closing quote must begin a new line that is indented
consistently with the line beginning the block. Their indentation is defined by the first non-blank
line in the block. All lines must contain at least this indentation (except the last). This fixed level of
indentation and the beginning and ending newline are removed. Aside from the removal of this
whitespace, the text block is simply quoted text containing newlines. For example:

macro(copyright, ['['
Copyright (c) 20xx
All rights reserved.
']'])
There is no parsing for code and text blocks as well as label syntaxes within text blocks. There is
parsing of M5 comments, quotes, and parentheses (counting) and quotes are recognized (and, of
course, number parameter substitutions will occur for a text block that is elaborated as part of a
macro body).

5.5.6. Evaluate Blocks
It can be convenient to form non-body arguments by evaluating code. Syntactic sugar is provided
for this in the form of a * preceding the block open quote.
For example, here a scoped evaluate code block is used to form an error message by searching for
negative arguments:

19

error(*{
~(['Arguments include negative values: '])
var(Comma, [''])
~for(Value, ['$@'], [
~if(m5_Value < 0, [
~Comma
set(Comma, [', '])
~Value
])
])
~(['.'])
})

5.5.7. Block Labels: Escaping Blocks and Labeled Numbered Parameters
Proper use of quotes can get a bit tedious, especially when it is necessary to escape out of several
levels of nested quotes. It can improve maintainability, code clarity, and performance to make
judicious use of block labels. Note, however, that the need for block labels is rare and is mostly
replaced by mechanisms provided by Functions.
Blocks can be labeled using syntax such as:

macro(my_macro, ..., <sf>{
})
Labels can be used in two ways.
• First, to escape out of a block, typically to generate text of the block.
• Second, to specify the block associated with a numbered parameter.
Both use cases are illustrated in the following example that attempts to declare a macro for parsing
text. This macro declares a helper macro ParseError for reporting parse errors that can be used
many times by my_parser.

/Parse a block of text.
macro(my_parser, {
var(Text, ['$1']) /// Text to parse
var(What, ['$2']) /// A description identifying what is begin parsed
/Report a parse error, e.g. m5_ParseError(['unrecognized character'])
macro(ParseError, {
error(['Parsing of ']m5_What[' failed with: "$1"'])
})
...
})
This code contains, potentially, two mistakes in the error message. First, m5_What will be substituted

20

at the time of the call to ParseError. As long as my_parser does not modify the value of What, this is
fine, but it might be preferred to expand m5_What in the definition itself to avoid this potential
Variable Masking issue in case What is reused.
Secondly, $1 will be substituted upon calling my_parser, not upon calling ParseError, and it will be
substituted with a null string.
The corrected example would use:

macro(ParseError, <err>{
error(['Parsing of ']<err>m5_What[' failed with: "$<err>1"'])
})

/// 2 Fixes!

This code corrects both issues:
• ']<err>m5_What[': This syntax acts in this case as ']']m5_nquote(1,m5_get(What))['[', escaping
enough levels of quoting to evaluate m5_What in the text of the err block and having the effect of
using the definition of m5_What at the time of the macro definition. (The added level of quotes
corresponds to the { / } block quotes which are sugar for [' / '].)
• $<err>1: This syntax associates $1 with the err block and is in this example equivalent to
']']m5_nquote_dollar(1,1)['['.

5.6. Syntax Checks and Pragmas
5.6.1. Indentation Checks
M5 checks that indentation is consistent for code and text blocks.

5.6.2. Quote and Parenthesis Matching
M5 checks that quotes (including [ / ] and { / } quotes for code blocks) are balanced. This is done
after comments are stripped. / quotes may be used to escape from block quotes within a line.
M5 checks that parentheses are balanced within block quotes. This is done after comments are
stripped.

5.6.3. Pragmas
In certain cases quote and parenthesis checking gets in the way. It is possible to disable checking
and control debug behavior using pragmas. Pragmas processing happens after M5 comments are
stripped. The following strings are recognized as pragmas:
• where_am_i: Prints the current quote context to STDERR.
• [enable/disable]_debug: Improves the readability of the file resulting from sugar processing,
and continues processing after normally-fatal errors.
• [enable/disable]_paren_checks: Enables or disables parenthesis tracking and reporting.
Enabling and disabling should be done at matching levels.

21

• [enable/disable]_quote_checks: Enables or disables reporting of quote mismatches.
• [enable/disable]_verbose_checks: Enables or disables verbose checking.
Since the pragmas would pass through to the target file, pragmas are generally expressed using the
following macro calls which elaborate to nothing:
• m5_pragma_where_am_i()
• m5_pragma_[enable/disable]_{check}(), where {check} is debug, paren_checks, quote_checks, or
verbose_checks.

6. Coding Practices
6.1. Coding Conventions
6.2. Status
The variable m5_status has a reserved usage. Some macros are defined to set m5_status. A nonempty value indicates that the macro did not perform its duties to the fullest. Several m5_if* macros
set non-empty status if they do not evaluate a body.
Macros such as m5_else and m5_if_so take action based on m5_status.
Well-behaved macros set m5_status always or never (and never is the assumption if no side effect is
listed in a macro’s documentation). Thus m5_status is more like a return value than a sticky flag.
Sticky behavior can be achieved using m5_sticky_status. There is no support for try-catch-like error
handling. In bodies of m5_macro it may be necessary to explicitly save and restore status to avoid
unintended side-effects on m5_status from calls within the bodies. m5_fn does this automatically. If
m5_status is checked, it is generally checked immediately after a call.

6.3. Functions
All but the simplest of macros are most often declared using m5_fn and similar macros. These
support a richer set of mechanisms for defining and passing parameter. While m5_macro is most
often used with a one-line body definition, m5_fn is most often used with multi-line bodies as Scoped
Code Blocks.
Such

m5_fn

declarations

using

Scoped

Code

Blocks

look

and

act

like

functions/procedures/subroutines/methods in a traditional programming language, and we often
refer to them as "functions". Function calls pass arguments into parameters. Functions' code block
bodies contain macro calls (statements) that define local variables, perform calculations, evaluate
code conditionally, iterate in loops, call other functions, recurse, etc.
Unlike typical programming languages, functions, like all macros, evaluate to text that substitutes
for the calls. There is no mechanism to explicitly print to the standard output stream (though there
are macros for printing to the standard error stream). Only a top-level call from the source code
will implicitly echo to standard output.

22

Functions are defined using: m5_fn and m5_lazy_fn.
Declarations take the form:

m5_fn(<name>, [<param-list>,] ['<body>'])
A basic function declaration with a one-line body looks like:

m5_fn(mul, val1, val2, ['m5_calc(m5_val1 * m5_val2)'])
Or, equivalently, using a code block body:

fn(mul, val1, val2, {
~calc(m5_val1 * m5_val2)
})
This mul function is called (in source context) like:

m5_mul(3, 5)

/// produces 15

6.3.1. Parameters
6.3.1.1. Parameters Types and Usage
• Numbered parameters: Numbered parameters, as in m5_macro (see Declaring Macros), can be
referenced as $1, $2, etc. with the same replacement behavior. However, they are explicitly
identified in the parameter list (see The Parameter List). Within the function body, similar to
['$3'], m5_fn_arg may also be used to access an argument. For example, m5_fn_arg(3) evaluates
to the literal third argument value.
• Special parameters: As for m5_macro, special parameters are supported. Note that: $@, $*, and $#
reflect only numbered parameters. Also, $0 will not have the expected value, however $0__ can
still be used as a name prefix to localize names to this function. (See Variable Masking.) Similar
to $@, the m5_fn_args macro (or variable) also provides a quoted list of the numbered arguments.
Similar to $#, the m5_fn_arg_cnt macro also provides the number of numbered arguments.
• Named parameters: These are available locally to the body as variables. They are not available
to the Aftermath of the function.
6.3.1.2. The Parameter List
The parameter list (<param-list>) is a list of zero or more <param-spec>s, where <param-spec> is:
• A parameter specification of the form: [?][[<number>]][[^]<name>][: <comment>] (in this order),
e.g. ?[2]^Name: the name of something:
◦ <name>: Name of a named parameter.

23

◦ ?: Specifies that the parameter is optional. Calls are checked to ensure that arguments are
provided for all non-optional parameters or are defined for inherited parameters. Nonoptional parameters may not follow optional ones.
◦ [<number>]: Number of a numbered parameter. The first must be [1] and would correspond
to $1 and m5_fn_arg(1), and so on. <number> is verified to match the sequential ordering of
numbered parameters. Numbered parameters may also be named, in which case they can
be accessed either way.
◦ ^: Specifies that the parameter is inherited. It must also be named. Its definition is inherited
from the context of the func definition. If undefined, the empty [''] value is provided and
an error is reported unless the parameter is optional, e.g. ?^<name>. There is no
corresponding argument in a call of this function. It is conventional to list inherited
parameters last (before the body) to maintain correspondence between the parameter list of
the definition and the argument list of a call.
◦ <comment>: A description of the parameter. In addition to commenting the code, this can be
extracted in documentation.
• …: Listed after last numbered parameter to allow extra numbered arguments. Without this,
extra arguments result in an error (except for the single empty argument of e.g. m5_foo(). See
Function Call Arguments.)

6.3.2. When To Use What Type of Parameter
For nested declarations, the use of numbered parameters ($1, $2, …) and special parameters ($@, $*,
$#, and $0) can be extremely awkward. Nested declarations are declarations within the bodies of
other declarations. Since nested bodies are part of outer bodies, numbered and special parameters
within them would actually substitute based on the outer bodies. This can be prevented by
generating the body with macros that produce the numbered parameter references, but this
requires an unnatural and bug prone use of quotes. Therefore the use of functions with named
parameters is preferred for inner macro declarations. Use of m5_fn_args and m5_fn_arg is also
simpler than using special parameters. If parameters are named, these are helpful primarily to
access … arguments or to pass argument lists to other functions.
Additionally, and in summary:
• Numbered/special parameters: These can be convenient to ensure substitution throughout the
body without interference from quotes. They can, however, be extremely awkward to use in
nested definitions as they would substitute with the arguments of the outer function/macro.
Being unnamed, readability is an issue, especially for large functions.
• Named parameters: These act more like typical function arguments vs. text substitution. Since
they are named, they can improve readability. Unlike numbered parameters, they work
perfectly well in functions defined within other functions/macros. (Similarly, m5_fn_args and
m5_fn_arg are useful for nested declarations.) Macros will not evaluate within quoted strings, so
typical use requires unquoting, e.g. ['Arg1: ']m5_arg1['.'] vs. ['Arg1: $1.'].
• Inherited parameters: These provide a more natural, readable, and explicit mechanism for
customizing a function to the context in which it is defined. For example a function may define
another function that is customized to the parameters of the outer function.

24

6.3.3. Function Call Arguments
Function calls must have arguments for all non-optional, non-inherited (^) parameters. Arguments
are positional, so misaligning arguments is a common source of errors. There is checking, however,
that required arguments are provided and that no extra arguments are given. m5_foo() is permitted
for a function foo declared with no parameters, though it is passed one emtpy parameter.
(m5_call(foo) might be preferred.)

6.3.4. Function Arguments Example
In M5 context, function foo is declared below to display its parameters.

// Context:
var(Inherit2, two)
// Define foo:
fn(foo, Param1, ?[1]Param2: an optional parameter,
?^Inherit1, [2]^Inherit2, ..., {
~nl(Param1: m5_Param1)
~nl(Param2: m5_Param2)
~nl(Inherit1: m5_Inherit1)
~nl(Inherit2: m5_Inherit2)
~nl(['numbered args: $@'])
})
And it can be called (again, in M5 context):

/Call foo:
foo(arg1, arg2, extra1, extra2)
And this expands to:

Param1: arg1
Param2: arg2
Inherit1:
Inherit2: two
numbered args: ['arg2'],['two'],['extra1'],['extra2']

6.3.5. Aftermath
It is possible for a function to make assignments (and, actually do anything) in the calling scope.
This can be done using m5_on_return or m5_return_status.
This is important for:
• passing arguments by reference
• returning status

25

• evaluating body arguments
• tail recursion
Each of these is discussed in its own section, next.

6.3.6. Passing Arguments by Reference
Functions can pass variables by reference and make assignments to the referenced variables upon
returning from the function. For example:

fn(update, FooRef, {
var(Value, ['updated value'])
on_return(set, m5_FooRef, m5_Value)
}
set(Foo, ['xxx'])
update(Foo)
~Foo
A similar function could be defined to declare a referenced variable by using var instead of set.
The use of m5_on_return avoids the potential masking issue that would result from:

update(Value)

6.3.7. Returning Status
A function’s m5_status should be returned via the function’s aftermath, using m5_return_status, e.g.

fn(my_fn, Val, {
if(m5_Val > 10, [''])
return_status(m5_status)
})
Functions automatically restore m5_status after body evaluation to its value prior to body
evaluation, so the evaluation of the body has no impact on m5_status. Aftermath is evaluated after
this. It is fine to call m5_return_status multiple times. Only the last call will have a visible effect.

6.3.8. Functions with Body Arguments
The example below illustrates a function if_neg that takes an argument that is a body to evaluate.
The body is defined in a calling function, e.g. my_fn on lines 15-16. Such a body is expected to
evaluate in the context of the calling function, my_fn. Its assignment of Neg, on line 15, should be an
assignment of its own local Neg, declared on line 12. Its side effects from m5_return_status on line 15
should be side effects of my_fn.
If the body is evaluated inside the function body, its side effects would be side effects of if_neg, not

26

my_fn. The body should instead be evaluated as aftermath, using m5_on_return, as on line 6.
Note

that

m5_return_status

is

called

after

evaluating

m5_Body.

Both

m5_on_return

and

m5_return_status add to the Aftermath of the function, and m5_status must be set after evaluating
the body (which could affect m5_status).
Example of a body argument.

1: // Evaluate a body if a value is negative.
2: fn(if_neg, Value, Body, {
3:
var(Neg, m5_calc(Value < 0))
4:
~if(Neg, [
5:
/~eval(m5_Body)
6:
on_return(Body)
7:
])
8:
return_status(if(Neg, [''], else))
9: })
10:
11: fn(my_fn, {
12:
var(Neg, [''])
13:
return_status(['pos'])
14:
~if_neg(1, [
15:
return_status(['neg'])
16:
set(Neg, ['-'])
17:
])
18:
...
19: })
Since m5_macro does not support Aftermath, it is not recommended to use m5_macro with a body
argument.

6.3.9. Tail Recursion
Recursive calls tend to grow the stack significantly, and this can result in an error (see
m5_recursion_limit) as well inefficiency. When recursion is the last act of the function ("tail
recursion"), the recursion can be performed in aftermath to avoid growing the stack. For example:

fn(my_fn, First, ..., {
...
~unless(m5_Done, [
...
on_return(my_fn\m5_comma_args())
])
...
})

27

6.4. Coding Paradigms, Patterns, Tips, Tricks, and
Gotchas
6.4.1. Variable Masking
Variable "masking" is an issue that can arise when a macro has side effects determined by its
arguments. For example, an argument might specify the name of a variable to assign, or an
argument might provide a body to evaluate that could declare or assign arbitrary variables. If the
macro declares a local variable, and the side effect updates a variable by the same name, the local
variable may inadvertently be the one that is updated by the side effect. This issue is addressed
differently depending how the macro is defined. Note that using function Aftermath is the
preferred method, but all options are listed here for completeness:
• Functions: Set variables using Aftermath. Using functions for variable-setting macros is
preferred.
• Macros declaring their body using a code block: Set variable using m5_out_eval.
• Macros declaring their body using a string: Push/pop local variables named using $0__ prefix.

7. Macro Library
7.1. Specification Conventions
Macros are listed by category in a logical order. An alphabetical Index of macros can be found at
the end of this document (at least in the .pdf version). Macros that return integer values, unless
otherwise specified, return decimal value strings. Similarly, macro arguments that are integer
values accept decimal value strings. Boolean inputs and outputs use 0 and 1. Behavior for other
argument values is undefined if unspecified.
Resulting output text is, by default, literal (quoted). Macros named with a _eval suffix generally
result in text that gets evaluated.

7.2. Assigning and Accessing Macros/Variables
7.2.1. Declaring/Setting Variables
m5_var(Name, Value, …)
Description: Declare a scoped variable. See Variables.
Side Effect(s): the variable is defined

28

Parameter(s): 1. Name: variable name
2. Value(opt) : the value for the variable
3. …: additional variables and values to declare (values are required)
Example(s):

var(Foo, 5)

See also: m5_macro, m5_fn

m5_set(Name, Value)
Description: Set the value of a scoped variable. See Variables.
Side Effect(s): the variable’s value is set
Parameter(s): 1. Name: variable name
2. Value: the value
Example(s):

set(Foo, 5)

See also: m5_var

m5_push_var(Name, Value)
Description: Declare a variable that must be explicitly popped.
Side Effect(s): the variable is defined
Parameter(s): 1. Name: variable name
2. Value: the value
Example(s):

push_var(Foo, 5)
...
pop(Foo)

See also: m5_pop

m5_pop(Name)

29

Description: Pop a variable or traditional macro declared using push_var or push_macro.
Side Effect(s): the macro is popped
Parameter(s): 1. Name: variable name
Example(s):

push_var(Foo, 5)
...
pop(Foo)

See also: m5_push_var, m5_push_macro

m5_null_vars(…)
Description: Declare variables with empty values.
Side Effect(s): the variables are declared
Parameter(s): 1. …: names of variables to declare

7.2.2. Declaring Macros
m5_fn(…)
m5_lazy_fn(…)
Description: Declare a function. For details, see Functions. fn and lazy_fn are functionally
equivalent but have different performance profiles, and lazy functions do not
support inherited (^) parameters. Lazy functions wait until they are used before
defining themselves, so they are generally preferred in libraries except for the
most commonly-used functions.
Side Effect(s): the function is declared
Parameter(s): 1. …: arguments and body
Example(s):

fn(add, Addend1, Addend2, {
~calc(Addend1 + Addend2)
})

See also: Functions

30

m5_macro(Name, Body)
m5_null_macro(Name, Body)
Description: Declare a scoped macro. See Declaring Macros. A null macro must produce no
output.
Side Effect(s): the macro is declared
Parameter(s): 1. Name: the macro name
2. Body: the body of the macro
Example(s):

m5_macro(ParseError, <p>[
error(['Failed to parse $<p>1.'])
])

See also: m5_var, m5_set_macro

m5_set_macro(Name, Body)
Description: Set the value of a scoped(?) macro. See Declaring Macros. Using this macro is rare.
Side Effect(s): the macro value is set
Parameter(s): 1. Name: the macro name
2. Body: the body of the macro
See also: m5_var, m5_set_macro

m5_push_macro(Name, Body)
Description: Push a new value of a macro that must be explicitly popped. Using this macro is
rare.
Side Effect(s): the macro value is pushed
Parameter(s): 1. Name: the macro name
2. Body: the body of the macro
See also: m5_pop, m5_macro, m5_set_macro

31

7.2.3. Accessing Macro/Variable Values
m5_get(Name)
Output: the value of a variable without $ substitution (even if not assigned as a string)
Parameter(s): 1. Name: name of the variable
Example(s):

Example
Output:

var(OneDollar, ['$1.00'])
get(OneDollar)

$1.00

See also: m5_var, m5_set

m5_must_exist(Name)
m5_var_must_exist(Name)
Description: Ensure that the Name`d macro (`must_exist) or variable (var_must_exist) exists.
Parameter(s): 1. Name: name of the macro/variable

7.3. Code Constructs
7.3.1. Status
m5_status (Universal variable)
Description: This universal variable is set as a side-effect of some macros to indicate an
exceptional condition or non-evaluation of a body argument. It may be desirable
to check this condition after calling such macros. Macros, like m5_else take action
based on the value of m5_status. An empty value indicates no special condition.
Macros either always set it (to an empty or non-empty value) or never set it.
Those that set it list this in their "Side Effect(s)".
See also: m5_fn, m5_return_status, m5_else, m5_sticky_status

m5_sticky_status (Universal variable)
Description: Used by the m5_sticky_status macro to capture the value of m5_status.

32

See also: m5_status, m5_sticky_status

m5_sticky_status()
Description: Used to capture the first non-empty status of multiple macro calls.
Side Effect(s): m5_sticky_status is set to m5_status if it is empty and m5_status is not.
Example(s):

if(m5_A >= m5_Min, [''])
sticky_status()
if(m5_A <= m5_Max, [''])
sticky_status()
if(m5_reset_sticky_status(), ['m5_error(m5_get(A) is out of range.)'])

See also: m5_status, m5_sticky_status, m5_reset_sticky_status

m5_reset_sticky_status()
Description: Tests and resets m5_sticky_status.
Output: [0 / 1] the original nullness of m5_sticky_status
Side Effect(s): m5_sticky_status is reset (emptied/nullified)
See also: m5_sticky_status

7.3.2. Conditionals
m5_if(Cond, TrueBody, …)
m5_unless(Cond, TrueBody, FalseBody)
m5_else_if(Cond, TrueBody, …)

33

Description: An if/else construct. The condition is an expression that evaluates using m5_calc
(generally boolean (0/1)). The first block is evaluated if the condition is non-0 (for
if and else_if) or 0 (for unless), otherwise, subsequent conditions are evaluated,
or if only one argument remains, it is the final else block, and it is evaluate.
(unless cannot have subsequent conditions.) if_else does nothing if m5_status is
initially empty.
As an alternative to providing else blocks within m5_if, m5_else
NOTE

and similar macros may be used subsequent to m5_if / m5_unless
and other macros producing m5_status, and this may be easier to
read.

Output: the output of the evaluated body
Side Effect(s): status is set, empty iff a block was evaluated; side-effects of the evaluated body
Parameter(s): 1. Cond: the condition for evaluation
2. TrueBody: the body to evaluate if the condition is true (1)
3. …: ['either a FalseBody or (for m5_if only) recursive Cond, TrueBody, …
arguments to evaluate if the condition is false (not 1)']
Example(s):

~if(m5_eq(m4_Ten, 10) && m5_Val > 3, [
~do_something(...)
], m5_Val > m5_Ten, [
~do_something_else(...)
], [
~default_case(...)
])

See also: m5_else, m5_case

m5_if_eq(String1, String2, TrueBody, …)
m5_if_neq(String1, String2, TrueBody, …)
Description: An if/else construct where each condition is a comparison of an independent pair
of strings. The first block is evaluated if the strings match (for if) or mismatch
(for if_neq), otherwise, the remaining arguments are processed in a recursive
call, either comparing the next pair of strings or, if only one argument remains,
evaluating it as the final else block.
NOTE

34

As an alternative to providing else blocks, m5_else and similar
macros may be used subsequently, and this may be easier to read.

Output: the output of the evaluated body
Side Effect(s): status is set, empty iff a body was evaluated; side-effects of the evaluated body
Parameter(s): 1. String1: the first string to compare
2. String2: the second string to compare
3. TrueBody: the body to evaluate if the strings match
4. …: either a FalseBody or recursive String1, String2, TrueBody, … arguments to
evaluate if the strings do not match
Example(s):

~if_eq(m4_Zero, 0, [
~zero_is_zero(...)
], m5_calc(m5_Zero < 0), 1, [
~zero_is_negative(...)
], [
~zero_is_positive(...)
])

See also: m5_else, m5_case

m5_if_null(Var, Body, ElseBody)
m5_if_def(Var, Body, ElseBody)
m5_if_ndef(Var, Body, ElseBody)
m5_if_defined_as(Var, Value, Body, ElseBody)
Description: Evaluate Body if the named variable is empty (if_null), defined (if_def), not
defined (if_ndef), or not defined and equal to the given value (if_defined_as)., or
ElseBody otherwise.
Output: the output of the evaluated body
Side Effect(s): status is set, empty iff a body was evaluated; side-effects of the evaluated body
Parameter(s): 1. Var: the variable’s name
2. Value: for if_defined_as only, the value to compare against
3. Body: the body to evaluate based on `m5_Name’s existence or definition
4. ElseBody(opt) : a body to evaluate if the condition if Body is not evaluated

35

Example(s):

if_null(Tag, [
error(No tag.)
])

See also: m5_if

m5_else(Body)
m5_if_so(Body)
Description: Likely following a macro that sets m5_status, this evaluates a body if m5_status is
non-empty (for else) or empty (for if_so).
Output: the output of the evaluated body
Side Effect(s): status is set, empty iff a body was evaluated; side-effects of the evaluated body
Parameter(s): 1. Body: the body to evaluate based on m5_status
Example(s):

~if(m5_Cnt > 0, [
decrement(Cnt)
])
else([
~(Done)
])

See also: m5_if, m5_if_eq, m5_if_neq, m5_if_null, m5_if_def, m5_if_ndef, m5_var_regex

m5_else_if_def(Name, Body)
Description: Evaluate Body iff the `Name`d variable is defined.
Output: the output of the evaluated body
Side Effect(s): status is set, empty iff a body was evaluated; side-effects of the evaluated body
Parameter(s): 1. Name: the name of the case variable whose value to compare against all cases
2. Body: the body to evaluate based on m5_status
Example(s):

36

m5_set(Either, if_def(First, m5_First)m5_else_if_def(Second,
m5_Second))

See also: m5_else_if, m5_if_def

m5_case(Name, Value, TrueBody, …)
Description: Similar to m5_if, but each condition is a string comparison against a value in the
Name variable.
Output: the output of the evaluated body
Side Effect(s): status is set, empty iff a block was evaluated; side-effects of the evaluated body
Parameter(s): 1. Name: the name of the case variable whose value to compare against all cases
2. Value: the first string value to compare VarName against
3. TrueBody: the body to evaluate if the strings match
4. …: either a FalseBody or recursive Value, TrueBody, … arguments to evaluate if
the strings do not match
Example(s):

~case(m5_Response, ok, [
~ok_response(...)
], bad, [
~bad_response(...)
], [
error(Unrecognized response: m5_Response)
])

See also: m5_else, m5_case

7.3.3. Loops
m5_loop(InitList, DoBody, WhileCond, WhileBody)
Description: A generalized loop construct. Implicit variable m5_LoopCnt starts at 0 and
increments by 1 with each iteration (after both blocks).
Output: output of the blocks
Side Effect(s): side-effects of the blocks

37

Parameter(s): 1. InitList: a parenthesized list, e.g. (Foo, 5, Bar, ok) of at least one variable,
initial-value pair providing variables scoped to the loop, or ['']
2. DoBody: a block to evaluate before evaluating WhileCond
3. WhileCond: an expression (evaluated with m5_calc) that determines whether to
continue the loop
4. WhileBody(opt) : a block to evaluate if WhileCond evaluates to true (1)
Example(s):

~loop((MyVar, 0), [
~do_stuff(...)
], m5_LoopCnt < 10, [
~do_more_stuff(...)
])

See also: m5_repeat, m5_for, m5_calc

m5_repeat(Cnt, Body)
Description: Evaluate a block a predetermined number of times. Implicit variable m5_LoopCnt
starts at 0 and increments by 1 with each iteration.
Output: output of the block
Side Effect(s): side-effects of the block
Parameter(s): 1. Cnt: the number of times to evaluate the body
2. Body: a block to evaluate Cnt times
Example(s):

~repeat(10, [
~do_stuff(...)
])

See also: m5_loop

m5_for(Var, List, Body)
Description: Evaluate a block for each item in a listed. Implicit variable m5_LoopCnt starts at 0
and increments by 1 with each iteration.
Output: output of the block

38

Side Effect(s): side-effects of the block
Parameter(s): 1. Var: the loop item variable
2. List: a list of items to iterate over, the last of which will be skipped if empty;
for each item, Var is set to the item, and Body is evaluated
3. Body: a block to evaluate for each item
Example(s):

~for(fruit, ['apple, orange, '], [
~do_stuff(...)
])

See also: m5_loop

7.3.4. Recursion
m5_recurse(max_depth, macro, …)
Description: Call a macro recursively to a given maximum recursion depth. Functions have a
built-in recursion limit, so this is only useful for macros.
Output: the output of the recursive call
Side Effect(s): the side effects of the recursive call
Parameter(s): 1. max_depth: the limit on the depth of recursive calls made through this macro
2. macro: the recursive macro to call
3. …: arguments for macro
Example(s):

m5_recurse(20, myself, args)

See also: m5_recursion_limit, m5_on_return

7.4. Working with Strings
7.4.1. Special Characters
m5_nl()

39

Description: Produce a new-line. Programmatically-generated output should always use this
macro (directly or indirectly) to produce new-lines, rather than using an actual
new-line in the source file. Thus the input file formatting can reflect the code
structure, not the output formatting.
Output: a new-line

m5_open_quote()
m5_close_quote()
Description: Produce an open or close quote. These should rarely (never?) be needed and
should be used with extra caution since they can create undetected imbalanced
quoting. The resulting quote is literal, but it will be interpreted as a quote if
evaluated.
Output: the literal quote
See also: m5_quote

m5_orig_open_quote()
m5_orig_close_quote()
Description: Produce [' or ']. These quotes in the original file are translated internally to
ASCII control characters, and in output (STDOUT and STDERR) these control
characters are translated to single-unicode-character "printable quotes". This
original quote syntax is most easily produced using these macros, and once
produced, has no special meaning in strings (though [ and ] have special meaning
in regular expressions).
Output: the literal quote
See also: m5_printable_open_quote, m5_printable_close_quote

m5_printable_open_quote()
m5_printable_close_quote()
Description: Produce the single unicode character used to represent [' or '] in output
(STDOUT and STDERR).
Output: the printable quote
See also: m5_orig_open_quote, m5_orig_close_quote

m5_UNDEFINED()

40

Description: A unique untypeable value indicating that no assignment has been made. This is
not used by any standard macro, but is available for explicit use.
Output: the value indicating "undefined"
Example(s):

m5_var(Foo, m5_UNDEFINED)
m5_if_eq(Foo, m5_UNDEFINED, ['['Foo is undefined.']'])
R: Foo is undefined.

7.4.2. Slicing and Dicing Strings
m5_append_var(Name, String)
m5_prepend_var(Name, String)
m5_append_macro(Name, String)
m5_prepend_macro(Name, String)
Description: Append or prepend to a variable or macro. (A macro evaluates its context; a
variable does not.)
Parameter(s): 1. Name: the variable name
2. String: the string to append/prepend
Example(s):

Example
Output:

m5_var(Hi, ['Hello'])
m5_append_var([', ']m5_Name['!'])
m5_Hi

Hello, Joe!

m5_substr(String, From, Length)
m5_substr_eval(String, From, Length)

41

Description: Extract a substring from String starting from Index and extending for Length
ASCII characters (unicode bytes) or to the end of the string if Length is omitted or
exceeds the string length. The first character of the string has index 0. The result
is empty if there is an error parsing From or Length, if From is beyond the end of the
string, or if Length is negative.
Extracting substrings from strings with quotes is dangerous as it can lead to
imbalanced quoting. If the resulting string would contain any quotes, an error is
reported suggesting the use of dequote and requote and the resulting string has its
quotes replaced by control characters.
Extracting substrings from UTF-8 strings (supporting unicode characters) is also
dangerous. M5 treats characters as bytes and UTF-8 characters can use multiple
bytes, so substrings can split UTF-8 characters. Such split UTF-8 characters will
result in bytes/M5-characters that have no special treatment in M5. They can be
rejoined to reform valid UTF-8 strings.
When evaluating substrings, care must be taken with ,, (, and ) because of their
meaning in argument parsing.
substr is a slow operation relative to substr_eval (due to limitations of M4).
Output: the substring or its evaluation
Parameter(s): 1. String: the string
2. From: the starting position of the substring
3. Length(opt) : the length of the substring
Example(s):

Example
Output:

m5_substr(['Hello World!'], 3, 5)

lo Wo

See also: m5_dequote, m5_requote

m5_join(Delimiter, …)
Output: the arguments, delimited by the given delimiter string
Parameter(s): 1. Delimiter: text to delimit arguments
2. …: arguments to concatenate (with delimitation)

42

Example(s):

Example
Output:

m5_join([', '], ['new-line'], ['m5_nl'], ['macro'])

new-line, m5_nl, macro

m5_translit(String, InChars, OutChars)
m5_translit_eval(String, InChars, OutChars)
Description: Transliterate a string, providing a set of character-for-character substitutions
(where a character is a unicode byte). translit_eval evaluates the resulting string.
Note that [' and '] are internally single characters. It is possible to substitute
these quotes (if balanced in the string and in the result) using translit_eval but
not using translit.
Output: the transliterated string (or its evaluation for translit_eval)
Side Effect(s): for translit_eval, the side-effects of the evaluation
Parameter(s): 1. String: the string to tranliterate
2. InChars: the input characters to replace
3. OutChars: the corresponding character replacements
Example(s):

Example
Output:

m5_translit(['Testing: 1, 2, 3.'], ['123'], ['ABC'])

Testing: A, B, C.

m5_uppercase(String)
m5_lowercase(String)
Description: Convert upper-case ASCII characters to lower-case.
Output: the converted string
Parameter(s): 1. String: the string
Example(s):

m5_uppercase(['Hello!'])

43

Example
Output:

HELLO!

m5_replicate(Cnt, String)
Description: Replicate a string the given number of times. (A non-evaluating version of
m5_repeat.)
Output: the replicated string
Parameter(s): 1. Cnt: the number of repetitions
2. String: the string to repeat
Example(s):

Example
Output:

m5_replicate(3, ['.'])

...

See also: m5_repeat

m5_strip_trailing_whitespace_from(Var)
Description: Strip trailing whitespace from the given variable.
Side Effect(s): the variable is updated
Parameter(s): 1. Var: the variable

7.4.3. Formatting Strings
m5_format_eval(string, …)

44

Description: Produce formatted output, much like the C printf function. The string argument
may contain % specifications that format values from … arguments.
From the M4 Manual, % specifiers include c, s, d, o, x, X, u, a, A, e, E, f, F, g, G, and %.
The following are also supported:
• field widths and precisions
• flags +, -, ` , `0, #, and '
• for integer specifiers, the width modifiers hh, h, and l
• for floating point specifiers, the width modifier l
Items not supported include positional arguments, the n, p, S, and C specifiers, the
z, t, j, L and ll modifiers, escape sequences, and any platform extensions
available in the native printf (for example, %a is supported even on platforms that
haven’t yet implemented C99 hexadecimal floating point output natively).
For more details on the functioning of printf, see the C Library Manual, or the
POSIX specification.
Output: the formatted string
Parameter(s): 1. string: the string to format
2. …: values to format, one for each % sequence in string
Example(s):

Example
Output:

1: m5_var(Foo, Hello)
m5_format_eval(`String "%s" uses %d chars.', Foo, m5_length(Foo))
2: m5_format_eval(`%*.*d', `-1', `-1', `1')
3: m5_format_eval(`%.0f', `56789.9876')
4: m5_length(m5_format(`%-*X', `5000', `1'))
5: m5_format_eval(`%010F', `infinity')
6: m5_format_eval(`%.1A', `1.999')
7: m5_format_eval(`%g', `0xa.P+1')

1:
String "Hello" uses 5 chars.
2: 1
3: 56790
4: 5000
5:
INF
6: 0X2.0P+0
7: 20

45

7.4.4. Inspecting Strings
m5_length(String)
Output: the length of a string in ASCII characters (unicode bytes)
Parameter(s): 1. String: the string

m5_index_of(String, Substring)
Output: the position in a string in ASCII characters (unicode bytes) of the first occurence
of a given substring or -1 if not present, where the string starts with character
zero
Parameter(s): 1. String: the string
2. Substring: the substring to find

m5_num_lines(String)
Output: the number of new-lines in the given string
Parameter(s): 1. String: the string

m5_for_each_line(Text, Body)
Description: Evaluate m5_Body for every line of m5_Text, with m5_Line assigned to the line
(without any new-lines).
Output: output from m5_Body
Side Effect(s): side-effects of m5_Body
Parameter(s): 1. Text: the block of text
2. Body: the body to evaluate for every m5_if of m5_Text

7.4.5. Safely Working with Strings
m5_dequote(String)
m5_requote(String)

46

Description: For strings that may contain quotes, working with substrings can lead to
imbalanced quotes and unpredictable behavior. dequote replaces quotes for
(different) control-character/byte quotes, aka "surrogate-quotes" that have no
special meaning. Dequoted strings can be safely sliced and diced, and once
reconstructed into strings containing balanced (surrogate) quotes, dequoted
strings can be requoted using requote.
Output: dequoted or requoted string
Parameter(s): 1. String: the string to dequote or requote

m5_output_with_restored_quotes(String)
Output: the given string with quotes, surrogate quotes and printable quotes replaced by
their original format ([''])
Parameter(s): 1. String: the string to output
See also: m5_printable_open_quote, m5_printable_close_quote

m5_no_quotes(String)
Description: Assert that the given string contains no quotes.
Parameter(s): 1. String: the string to test

7.4.6. Regular Expressions
Regular expressions in M5 use the same regular expression syntax as GNU Emacs. (See GNU Emacs
Regular Expressions.) This syntax is similar to BRE, Basic Regular Expressions in POSIX and is
regrettably rather limited. Extended Regular Expressions are not supported.
m5_regex(String, Regex, Replacement)
m5_regex_eval(String, Regex, Replacement)
Description: Searches for Regexp in String, resulting in either the position of the match or the
given replacement.
Replacement provides the output text. It may contain references to subexpressions
of Regex to expand in the output. In Replacement, \n references the nth
parenthesized subexpression of Regexp, up to nine subexpressions, while \& refers
to the text of the entire regular expression matched. For all other characters, a
preceding \ treats the character literally.

47

Output: If Replacement is omitted, the index of the first match of Regexp in String is
produced (where the first character in the string has an index of 0), or -1 is
produced if there is no match.
If Replacement is given and there was a match, this argument provides the output,
with \n replaced by the corresponding matched subexpressions of Regex and \&
replaced by the entire matched substring. If there was no match result is empty.
The resulting text is literal for regex and is evaluated for regex_eval.
Side Effect(s): regex_eval may result in side-effects resulting from the evaluation of Replacement.
Parameter(s): 1. String: the string to search
2. Regex: the regular expression to match
3. Replacement(opt) : the replacement
Example(s):

Example
Output:

m5_regex_eval(['Hello there'], ['\w+'], ['First word:
m5_translit(['\&']).'])

First word: Hello.

See also: m5_var_regex, m5_if_regex, m5_for_each_regex

m5_var_regex(String, Regex, VarList)
Description: Declare variables assigned to subexpressions of a regular expression.
Side Effect(s): status is assigned, non-empty iff no match.
Parameter(s): 1. String: the string to match
2. Regex: the Gnu Emacs regular expression
3. VarList: a list in parentheses of variables to declare for subexpressions
Example(s):

m5_var_regex(['mul A, B'], ['^\(\w+\)\s+\(w+\),\s*\(w+\)$'],
(Operation, Src1, Src2))
m5_if_so(['m5_DEBUG(Matched: m5_Src1[','] m5_Src2)'])
m5_else(['m5_error(['Match failed.'])'])

See also: m5_regex, m5_regex_eval, m5_if_regex, m5_for_each_regex

48

m5_if_regex(String, Regex, VarList, Body, …)
m5_else_if_regex(String, Regex, VarList, Body, …)
Description: For chaining var_regex to parse text that could match a number of formats. Each
pattern match is in its own scope. else_if_regex does nothing if m5_status is nonempty.
Output: output of the matching body
Side Effect(s): m5_status is non-null if no expression matched; side-effects of the bodies
Parameter(s): 1. String: the string to match
2. Regex: the Gnu Emacs regular expression
3. VarList: a list in parentheses of variables to declare for subexpressions
4. Body: the body to evaluate if the pattern matches
5. …: additional repeated Regex, VarList, Body, … to process if pattern doesn’t
match
Example(s):

~if_regex(m5_Instruction, ['^mul\s+\(w+\),\s*\(w+\)$'], (Src1, Src2),
[
~calc(m5_Src1 * m5_Src2)
], ['^incr\s+\(w+\)$'], (Src1), [
~calc(m5_Src1 + 1)
])

See also: m5_var_regex

m5_for_each_regex(String, Regex, VarList, Body)
Description: Evaluate body for every pattern matching regex in the string. m5_status is
unassigned.
Side Effect(s): side-effects of evaluating the body
Parameter(s): 1. String: the string to match (containing at least one subexpression and no $)
2. Regex: the Gnu Emacs regular expression
3. VarList: a (non-empty) list in parentheses of variables to declare for
subexpressions
4. Body: the body to evaluate for each matching expression

49

Example(s):

m5_for_each_regex(H1dd3n D1git5, ['\([0-9]\)'], (Digit), ['Found
m5_Digit. '])

Example

Found 1. Found 3. Found 1. Found 5.

Output:

See also: m5_regex, m5_regex_eval, m5_if_regex, m5_else_if_regex

7.5. Utilities
7.5.1. Fundamental Macros
m5_defn(Name)
Output: the M4 definition of a macro; note that the M4 definition is slightly different from
the M5 definition
Parameter(s): 1. Name: the name of the macro

m5_call(Name, …)
Description: Call a macro. Versus directly calling a macro, this indirect mechanism has two
primary uses. First it provides a consistent syntax for calls with zero arguments
as for calls with a non-zero number of arguments. Second, the macro name can
be constructed.
Output: the output of the called macro
Side Effect(s): the side-effects of the called macro
Parameter(s): 1. Name: the name of the macro to call
2. …: the arguments of the macro to call
Example(s):

m5_call(error, ['Fail!'])

See also: m5_comma_shift, m5_comma_args

m5_quote(…)

50

Output: a comma-separated list of quoted arguments, i.e. $@
Parameter(s): 1. …: arguments to be quoted
Example(s):

Example
Output:

m5_quote(A, ['B'])

['A'],['B']

See also: m5_nquote

m5_nquote(…)
Output: the arguments within the given number of quotes, the innermost applying
individually to each argument, separated by commas. A num of 0 results in the
inlining of $@.
Parameter(s): 1. …:
Example(s):

Example
Output:

1: m5_nquote(3, A, ['m5_nl'])
2: m5_nquote(3, m5_nquote(0, A, ['m5_nl'])xx)

1: ['['['A'],['m5_nl']']']
2: ['['['A'],['m5_nlxx']']']

See also: m5_quote

m5_eval(Expr)
Description: Evaluate the argument.
Output: the result of evaluating the argument
Side Effect(s): the side-effects resulting from evaluation
Parameter(s): 1. Expr: the expression to evaluate

51

Example(s):

1: m5_eval(['m5_calc(1 + 1)'])
2: m5_eval(['m5'])_calc(1 + 1)

Example

1: 2
2: m5_calc(1 + 1)

Output:

m5_comment(…)
m5_nullify(…)
Output: nothing at all; used to provide a comment (though [comments] are preferred) or
to discard the result of an evaluation
Parameter(s): 1. …:

7.5.2. Manipulating Macro Stacks
See [stacks].
m5_get_ago(Name, Ago)
Output:
Parameter(s): 1. Name: variable name
2. Ago: 0 for current definition, 1 for previous, and so on
Example(s):

*{
var(Foo, A)
var(Foo, B)
~get_ago(Foo, 1)
~get_ago(Foo, 0)
}

Example
Output:

AB

m5_depth_of(Name)
Output: the number of values on a variable’s stack
Parameter(s): 1. Name: macro name

52

Example(s):

m5_depth_of(Foo)
m5_push_var(Foo, A)
m5_depth_of(Foo)

Example

0

Output:

1

7.5.3. Argument Processing
m5_shift(…)
m5_comma_shift(…)
Description: Removes the first argument. comma_shift includes a leading , if there are more
than zero arguments.
Output: a list of remaining arguments, or [''] if less than two arguments
Side Effect(s): none
Parameter(s): 1. …: arguments to shift
Example(s):

m5_foo(m5_shift($@))
/// $@ has at least 2 arguments
m5_call(foo['']m5_comma_shift($@)) /// $@ has at least 1 argument

m5_nargs(…)
Output: the number of arguments given (useful for variables that contain lists)
Parameter(s): 1. …: arguments
Example(s):

Example
Output:

m5_set(ExampleList, ['hi, there'])
m5_nargs(m5_ExampleList)

2

m5_argn(ArgNum, …)

53

Output: the nth of the given arguments or [''] for non-existent arguments
Parameter(s): 1. ArgNum: the argument number (n) (must be positive)
2. …: arguments
Example(s):

m5_set(ExampleList, ['hi, there'])
m5_argn(2, ExampleList)

Example

there

Output:

m5_comma_args(…)
Description: Convert a quoted argument list to a list of arguments with a preceding comma.
This is necessary to properly work with argument lists that may contain zero
arguments.
Parameter(s): 1. …: quoted argument list
Example(s):

m5_call(foo['']m5_comma_args(['$@']), last)

See also: m5_comma_shift, m5_comma_fn_args

m5_echo_args(…)
Description: For rather pathological use illustrated in the example, …
Output: the argument list ($@)
Parameter(s): 1. …: the arguments to output
Example(s):

Example
Output:

54

m5_macro(append_to_paren_list, ['m5_echo_args$1, ${empty}2'])
m5_append_to_paren_list((one, two), three)

(one,two,three)

7.5.4. Arithmetic Macros
m5_calc(Expr, Radix, Width)

55

Description: Calculate an expression. Calculations are done with 32-bit signed integers.
Overflow silently results in wraparound. A warning is issued if division by zero is
attempted, or if the expression could not be parsed. Expressions can contain the
following operators, listed in order of decreasing precedence.
• (): For grouping subexpressions
• +, -, ~, !: Unary plus and minus, and bitwise and logical negation
• **: Exponentiation (exponent must be non-negative, and at least one
argument must be non-zero)
• *, %: Multiplication, division, and modulo
• + -: Addition and subtraction
• <<, >>: Shift left or right (for shift amounts > 32, the amount is implicitly
ANDed with 0x1f)
• >, >=, <, ⇐: Relational operators
• ==, !=: Equality operators
• &: Bitwise AND
• ^: Bitwise XOR (exclusive or)
• |: Bitwise OR
• &&: Logical AND
• ||: Logical OR
All binary operators, except exponentiation, are left-associative. Exponentiation
is right-associative.
Immediate values in Expr may be expressed in any radix (aka base) from 1 to 36
using prefixes as follows:
• (none): Decimal (base 10)
• 0: Octal (base 8)
• 0x: hexadecimal (base 16)
• 0b: binary (base 2)
• 0r:, where r is the radix in decimal: Base r.
Digits are 0, 1, 2, …, 9, a, b … z. Lower and upper case letters can be used
interchangeably in numbers and prefixes. For radix 1, leading zeros are ignored,
and all remaining digits must be 1.
For the relational operators, a true relation returns 1, and a false relation return
0.

56

Output: the calculated value of the expression in the given Radix; the value is zeroextended as requested by Width; values may have a negative sign (-) and they
have no radix prefix; digits > 9 use lower-case letters; output is empty if the
expression is invalid
Parameter(s): 1. Expr: the expression to calculate
2. Radix(opt) : the radix of the output (default 10)
3. Width(opt) : a minimum width to which to zero-pad the result if necessary
(excluding a possible negative sign)
Example(s):

Example
Output:

1: m5_calc(2**3 <= 4)
2: m5_calc(-0xf, 2, 8)

1: 0
2: -00001111

m5_equate(Name, Expr)
m5_operate_on(Name, Expr)
Description: Set a variable to the result of an arithmetic expression computed by m5_calc. For
m5_operate_on, the variable value implicitly preceeds the expression, similar to +=,
*=, etc. in other languages.
Side Effect(s): the variable is set
Parameter(s): 1. Name: name of the variable to set
2. Expr: the expression/partial-expression to evaluate
Example(s):

Example
Output:

m5_equate(Foo, 1+2)
m5_operate_on(Foo, * (3-1))
m5_Foo

6

See also: m5_set, m5_calc

m5_increment(Name, Amount)
m5_decrement(Name, Amount)

57

Description: Increment/decrement a variable holding an integer value by one or by the given
amount.
Side Effect(s): the variable is updated
Parameter(s): 1. Name: name of the variable to set
2. Amount(opt) : the integer amount to increment/decrement, defaulting to zero
Example(s):

m5_increment(Cnt)

See also: m5_set, m5_calc, m5_operate_on

7.5.5. Boolean Macros
These have boolean (0 / 1) results. Note that some m5_calc expressions result in boolean values as
well.
m5_is_null(Name)
m5_isnt_null(Name)
Output: [0 / 1] indicating whether the value of the given variable (which must exist) is
empty
Parameter(s): 1. Name: the variable name

m5_eq(String1, String2, …)
m5_neq(String1, String2, …)
Output: [0 / 1] indicating whether the given String1 is/is-not equivalent to String2 or any
of the remaining string arguments
Parameter(s): 1. String1: the first string
2. String2: the second string
3. …: further strings to also compare
Example(s):

58

m5_if(m5_neq(m5_Response, ok, bad), ['m5_error(Unknown response:
m5_Response.)'])

7.5.6. Within Functions or Code Blocks
m5_fn_args()
m5_comma_fn_args()
Description: m5_fn_args() results in the numbered argument list of the current function. This
is like $@, but it can be used in a nested function without escaping (e.g. $<label>@).
m5_comma_fn_args() is the same, but has a preceeding comma if the list is nonempty.

Note

that

these

can

be

used

as

variables

(m5_fn_args

and

m5_comman_fn_args) to provide quoted versions of these.
Output:
Side Effect(s): none
Example(s):

m5_foo(1, m5_fn_args())
m5_foo(1['']m5_comma_fn_args())

/// works for 1 or more fn_args
/// works for 0 or more fn_args

See also: m5_fn_arg, m5_fn_arg_cnt

m5_fn_arg(Num)
Description: Access a function argument by position from m5_fn_args. This is like, e.g. $3, but is
can be used in a nested function without escaping (e.g. $<label>3), and can be
parameterized (e.g. m5_fn_arg(m5_ArgNum)).
Output: the argument value.
Parameter(s): 1. Num: the argument number
See also: m5_fn_args, m5_fn_arg_cnt

m5_fn_arg_cnt()
Description: The number of arguments in m5_fn_args or $#. This is like, e.g. $#, but is can be
used in a nested function without escaping (e.g. $<label>#).
Output: the argument value.
See also: m5_fn_args, m5_fn_arg

m5_out(String)
m5_out_eval(String)

59

Description: These append to code block output that is expanded after the evaluation of the
block. m5_out captures literal text, while the argument to m5_get(out_eval) gets
evaluated. Thus m5_get(out_eval) is useful for code block side effects. m5_out is
useful only in pathological cases within statements and by dynamically
constructed code since the shorthand syntax ~(…) is effectively identical to
~out(…). Note that these macros are not recommended for use in function blocks
as functions have their own mechanism for side effects that applies outside of the
function (after popping parameters). (See Aftermath.)
Output: no direct output, though, since these indirectly result in output as a side-effect, it
is recommended to use ~ statement syntax with these
Side Effect(s): indirectly, out_eval can result in the side effects of its output expression
Parameter(s): 1. String: the string to output
See also: Code Blocks, Aftermath

m5_return_status(Value)
Description: Provide return status. (Shorthand for m5_on_return(set, status, m5_Value).) This
negates any prior calls to return_status from the same function.
Side Effect(s): sets m5_status
Parameter(s): 1. Value(opt) : the status value to return, defaulting to the current value of
m5_status
See also: m5_on_return, Status, Aftermath

m5_on_return(…, D, MacroName, …)
Parameter(s): 1. …
2. D: Call a macro upon returning from a function. Arguments are those for
m5_call.
3. MacroName: the name of the macro to call
4. …: its arguments

7.6. Checking and Debugging
m5_debug_level(level)

60

Description: Get or set the debug level.
Output: with zero arguments, the current debug level
Side Effect(s): sets debug_level
Parameter(s): 1. level(opt) : [min, default, max] the debug level to set
Example(s):

debug_level(max)
use(m5-1.0)

7.6.1. Checking and Reporting to STDERR
These macros output text to the standard error output stream (STDERR) (with [' / '] quotes
represented by single characters). (Note that STDOUT is the destination for the evaluated output.)
m5_errprint(text)
m5_errprint_nl(text)
Description: Write to STDERR stream (with a trailing new-line for errprint_nl).
Parameter(s): 1. text: the text to output
Example(s):

m5_errprint_nl(['Hello World.'])

m5_warning(message)
m5_error(message)
m5_fatal_error(message)
m5_DEBUG(message)
Description: Report an error/warning/debug message and stack trace (except for DEBUG_if).
Exit for fatal_error, with non-zero exit code.
Parameter(s): 1. message: the message to report; (Error: pre-text (for example) provided by the
macro)
Example(s):

m5_error(['Parsing failed.'])

m5_warning_if(condition, message)
m5_error_if(condition, message)

61

m5_fatal_error_if(condition, message)
m5_DEBUG_if(condition, message)
Description: Report an error/warning/debug message and stack trace (except for DEBUG_if) if
the given condition is true. Exit for fatal_error, with non-zero exit code.
Parameter(s): 1. condition: the condition, as in m5_if.
2. message: the message to report; (Error: pre-text (for example) provided by the
macro)
Example(s):

m5_error_if(m5_Cnt < 0, ['Negative count.'])

m5_assert(message)
m5_fatal_assert(message)
Description: Assert that a condition is true, reporting an error if it is not, e.g. Error: Failed
assertion: -1 < 0. Exit for fatal_error, with non-zero exit code.
Parameter(s): 1. message: the message to report; (Error: pre-text (for example) provided by the
macro)
Example(s):

m5_assert(m5_Cnt < 0)

m5_verify_min_args(Name, Min, Actual)
m5_verify_num_args(Name, Min, Actual)
m5_verify_min_max_args(Name, Min, Max, Actual)
Description: Verify that a traditional macro has a minimum number, a range, or an exact
number of arguments.
Parameter(s): 1. Name: the name of this macro (for error message)
2. Min: the required minimum or exact number of arguments
3. Max: the maximum number of arguments
4. Actual: the actual number of arguments
Example(s):

62

m5_verify_min_args(my_fn, 2, $#)

7.6.2. Uncategorized Debug Macros
m5_recursion_limit (Universal variable)
Description: If the function call stack exceeds this value, a fatal error is reported.

m5_abbreviate_args(max_args, max_arg_length, …)
Description: For reporting messages containing argument lists, abbreviate long arguments
and/or a long argument list by replacing long input args and remaining
arguments beyond a limit with ['…'].
Output: a quoted string of quoted args with a comma preceding every arg.
Parameter(s): 1. max_args: if more than this number of args are given, additional args are
represented as ['…']
2. max_arg_length: maximum length in characters to display of each argument
3. …: arguments to represent in output
Example(s):

m5_abbreviate_args(5, 15, $@)

8. Reference Card
M5 processes the following syntaxes:
Table 1. Core Syntax

Use

Reference

Syntax

M5 comments

Comments

///, /**, **/

Quotes

Quotes

[', ']

Macro calls

Calling Macros

e.g. m5_my_fn(arg1, arg2)

Numbered/special Declaring Macros

$ (e.g. $3, $@, $#, $*)

parameters
Escapes

Backslash Word Boundary

\['']m5_get(foo), m5_foo

(m5_\ and \m5_)
Additionally, text and code block syntax is recognized when special quotes are opened at the end of
a line or closed at the beginning of a line. See Code Blocks. For example:

63

/Report error.
error(*<blk>{
~(['Something went wrong!'])
})
Block syntax incudes:
Table 2. Block Syntax

Use

Reference

Syntax

Code block quotes Code Blocks

[, ], {, } (ending/beginning a line)

Text block quotes

Text Blocks

[', '] (ending/beginning a line)

Evaluate Blocks

Evaluate Blocks

*[, [, *{, }, *[', ']

Statement

Statement Comments (E.g. /) /Blah blah blah…

comment
Statement with no Code Blocks

foo, bar(…) (m5_ prefix implied)

output
Code block

[bCode Blocks]

~foo, ~bar(…) (m5_ prefix implied)

statement with
output
Code block output Code Blocks

~(…)

Though not essential, block labels can be used to improve maintainability and performance in
extreme cases.
Table 3. Block Label Syntax

Use

Reference

Syntax

Named blocks

Block Labels: Escaping

<foo> (preceding the open quote, after optional

Blocks and Labeled

*) e.g. *<bar>{ or <baz>['

Numbered Parameters
Quote escape

Block Labels: Escaping

']<foo>m5_Bar['

Blocks and Labeled
Numbered Parameters
Labeled

Block Labels: Escaping

number/special

Blocks and Labeled

parameter

Numbered Parameters

$<foo>, e.g. $<foo>2 or $<bar>#

reference
Many macros accept arguments with syntaxes of their own, defined in the macro definition.
Functions, for example are fundamental. See Functions.

64

Index
A

fn_arg, 59

abbreviate_args, 63

fn_arg_cnt, 59

append_macro, 41
append_var, 41
argn, 53
assert, 62
C
calc, 55
call, 50
case, 37
close_quote, 40
comma_args, 54
comma_fn_args, 59
comma_shift, 53

fn_args, 59
for, 38
for_each_line, 46
for_each_regex, 49
format_eval, 44
G
get, 32
get_ago, 52
I
if, 33
if_def, 35

comment, 52

if_defined_as, 35

D

if_ndef, 35

DEBUG, 61

if_neq, 34

DEBUG_if, 62
debug_level, 60
decrement, 57
defn, 50
depth_of, 52
dequote, 46
E
echo_args, 54
else, 36
else_if, 33
else_if_def, 36
else_if_regex, 49
eq, 58
equate, 57
error, 61
error_if, 61
errprint, 61
errprint_nl, 61
eval, 51
F
fatal_assert, 62
fatal_error, 61
fatal_error_if, 62
fn, 30

if_eq, 34

if_null, 35
if_regex, 49
if_so, 36
increment, 57
index_of, 46
is_null, 58
isnt_null, 58
J
join, 42
L
lazy_fn, 30
length, 46
loop, 37
lowercase, 43
M
macro, 31
must_exist, 32
N
nargs, 53
neq, 58
nl, 39
no_quotes, 47

65

nquote, 51

T

null_macro, 31

translit, 43

null_vars, 30
nullify, 52
num_lines, 46
O
on_return, 60
open_quote, 40

translit_eval, 43
U
UNDEFINED, 40
unless, 33
uppercase, 43

operate_on, 57

V

orig_close_quote, 40

var, 28

orig_open_quote, 40
out, 59
out_eval, 59
output_with_restored_quotes, 47
P

var_must_exist, 32
var_regex, 48
verify_min_args, 62
verify_min_max_args, 62
verify_num_args, 62

pop, 29

W

prepend_macro, 41

warning, 61

prepend_var, 41
printable_close_quote, 40
printable_open_quote, 40
push_macro, 31
push_var, 29
Q
quote, 50
R
recurse, 39
recursion_limit, 63
regex, 47
regex_eval, 47
repeat, 38
replicate, 44
requote, 46
reset_sticky_status, 33
return_status, 60
S
set, 29
set_macro, 31
shift, 53
status, 32
sticky_status, 32, 33
strip_trailing_whitespace_from, 44
substr, 41
substr_eval, 41

66

warning_if, 61

